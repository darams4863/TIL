---
title: "Redis 면접용 질문 - basic"
date: 2025-08-04
categories:
  - redis
tags:
  - redis
  - interview
  - questions
  - answers
---

# Redis Basic 면접 질문 & 답변
3년차 파이썬 백엔드 개발자 기준, Redis 화이트보드/면접 대비용 기본 질문들

---

## 1️⃣ Redis 기본 개념

**Q1. Redis는 무엇이고, 어떤 특징을 가지나요?**

```text
Redis는 In-Memory 기반의 Key-Value NoSQL 데이터 저장소입니다.
RAM에 데이터를 저장해 밀리초~마이크로초 단위의 접근 속도를 제공하며,
String, Hash, List, Set, Sorted Set, Stream 등 다양한 자료구조를 지원합니다.
이렇게 다양한 자료구조 덕분에 캐시, 세션 관리, 작업 큐, Pub/Sub 등 다양한 용도로 활용됩니다.
```

**꼬리질문**

* Q1-1. 왜 메모리 기반인데도 안정적인가요?

```text
레디스는 메모리 기반이어도 RDB Snapshot, AOF(Append Only File)로 영속성을 제공하고,
Master-Replica, Sentinel/Cluster 모드로 가용성을 높일 수 있기 때문에 메모리 기반이어도 안정적이라고 합니다.
```

* Q1-2. Redis는 싱글 스레드인데 왜 빠른가요?

```text
Redis가 싱글 스레드임에도 빠른 이유는 몇 가지로 정리할 수 있습니다.

첫 번째로, Redis는 모든 데이터를 메모리에 저장해서 접근하기 때문에
디스크 I/O가 거의 없고, 마이크로초 단위로 데이터를 처리할 수 있어요.

두 번째로, 싱글 스레드 구조 덕분에 락 경합(lock contention)이 없어요.
여러 스레드 간 문맥 전환(context switching)이나 동기화 비용이 없어서
오히려 단일 스레드가 빠르게 이벤트 루프를 돌면서 처리할 수 있습니다.

세 번째로, 내부적으로 epoll 같은 I/O 멀티플렉싱 방식을 사용해서
동시에 많은 요청을 처리하더라도 대기 없이 빠르게 응답을 줄 수 있어요.

정리하면, 메모리 기반 구조 + 문맥 교환 비용이 없음 + 이벤트 루프 기반의 I/O 멀티플렉싱
이 세 가지가 합쳐져서 싱글 스레드임에도 매우 높은 성능을 냅니다.
```

* Q1-3. RDB랑 AOF를 같이 쓰면 어떤 장단점이 있나요?
```text
RDB는 일정 주기로 백그라운드에서 돌면서 메모리 상태를 통째로 스냅샷으로 저장하고,
AOF는 모든 쓰기 명령을 로그처럼 기록해서
재시작 시 순차적으로 재생하여 영속성을 보장하는 방식입니다. 

실무에서는 두 가지를 함께 사용하면 
성능과 데이터 안정성을 둘 다 확보할 수 있습니다.

대신 단점은 디스크 I/O가 늘어나고, 
AOF 재생 시 초기 부팅이 조금 더 느려질 수 있다는 점이 있습니다.
```

---

## 2️⃣ 자료구조 & 활용

**Q2. Redis에서 지원하는 자료구조 5가지를 말하고 용도를 설명해주세요.**

```text
1. String: 단순 Key-Value, 카운터, 락
2. Hash: 객체 저장, 유저 프로필 관리
3. List: 큐(FIFO), 작업 대기열
4. Set: 중복 없는 집합, 팔로워 목록
5. Sorted Set: 점수 기반 정렬, 랭킹
추가: Stream – 로그 수집, 주문 처리, 결제 이벤트 (처럼 메세지를 여러 소비자가 처리하거나 나중에 재처리 할 수 있게 저장하는게 필요한 상황에 적합)
추가: Pub/Sub – 채팅방 알림, 게임 이벤트 알림 (한 번 보내고 끝나는 메세징에 적합. 저장 x)
```

**꼬리질문**

* Q2-1. Sorted Set과 List 차이와 활용 예시는?

```text
Sorted Set은 점수(score) 기반으로 자동 정렬돼서
랭킹이나 일정 관리처럼 우선순위가 있는 데이터를 다룰 때 적합해요.
예를 들어 게임 유저 점수 랭킹이나, 시간순으로 처리해야 하는 작업 스케줄링이요.

List는 단순히 순서가 있는 자료구조라
작업 큐나 스택, FIFO 메시지 큐처럼 순차 처리에 쓰기 좋아요.
```

* Q2-2. Stream과 Pub/Sub의 차이는?

```text
Pub/Sub은 실시간으로 메시지를 브로드캐스트할 때 쓰고,
메시지를 따로 저장하지 않아요. 
그래서 구독자가 없으면 메시지가 그냥 사라집니다.
대표적으로 채팅방 알림, 실시간 주식 시세 같은 경우죠.

Stream은 메시지를 저장하고,
Consumer Group으로 나눠서 처리할 수 있어요.
또 ack를 지원해서 메시지를 안전하게 확인하고
나중에 재처리할 수도 있어서
주문 처리나 로그 수집 같은 시나리오에 적합합니다.
```

---

## 3️⃣ TTL & 메모리 관리

**Q3. Redis에서 키 만료(TTL)는 어떻게 동작하나요?**

```text
Redis는 키에 TTL(Time To Live)을 설정할 수 있고, 만료된 키는 두 가지 정책으로 삭제됩니다.

1. Lazy Expiration: 클라이언트가 키를 조회할 때 만료 여부를 확인하고 삭제
2. Active Expiration: 백그라운드에서 주기적으로 샘플링해 만료된 키를 삭제

Redis는 이 두 가지 정책을 혼합해서 TTL을 관리합니다.
```

**꼬리질문**

* Q3-1. TTL 수백만 개 시 어떤 문제가 발생하나요?
```text
동시에 많은 키가 만료되면 CPU 사용량이 급격히 올라가면서 CPU spike가 발생하고,
이에 따라 Redis 응답이 순간적으로 느려질 수 있습니다.
이 현상을 TTL Storm이라고 부릅니다.

이를 방지하기 위해서는,
1. TTL 시간을 분산 설정 (random offset 추가)
   - 키 추가 시 ±n초를 랜덤으로 더해 만료 시점을 분산
2. 만료 이벤트를 균등하게 퍼트리는 Expiration spread
   - 키 생성 시점에 따라 TTL을 다양하게 설정해 만료가 한꺼번에 몰리지 않도록 조정
```

* Q3-2. 메모리 부족 시 Redis 동작은?
```text
Redis는 설정해둔 maxmemory 정책에 따라 키를 지워요.  
예를 들어 allkeys-lru로 설정하면 전체 키 중에서 가장 오래 안 쓰인 키부터 지우고,  
volatile-lru면 TTL이 걸려 있는 키 중에서 오래 안 쓰인 키만 지웁니다.  
랜덤으로 지우는 allkeys-random 같은 정책도 있고요.

만약 이런 정책으로도 공간을 확보하지 못하면 OOM(Out Of Memory) 에러가 나요.  
즉, 메모리가 꽉 차서 새 데이터를 더 못 넣는 상태를 말합니다.

보통 캐시 용도로 쓸 때는 allkeys-lru나 volatile-lru를 설정해서  
OOM(메모리 부족) 상황을 예방하는 게 안전합니다.
```

---

## 4️⃣ Persistence & 복제

**Q4. Redis의 영속성 방식에는 무엇이 있나요?**

```text
Redis는 메모리 기반이지만 데이터를 잃지 않으려면 영속성을 켤 수 있습니다.  
크게 세 가지 방식이 있습니다.

1. **RDB(Snapshot)**: 특정 시점에 메모리를 통째로 덤프해서 스냅샷을 저장합니다.  
   - 장점: 백업이 빠르고 파일이 작습니다.  
   - 단점: 스냅샷 사이에 장애가 나면 그 사이 데이터는 유실될 수 있습니다.

2. **AOF(Append Only File)**: 모든 write 명령을 로그에 순차적으로 기록합니다.  
   - 장점: 데이터 유실이 최소화됩니다.  
   - 단점: 파일이 커지고, 복구 속도가 느려질 수 있습니다.

3. **Mixed Mode (RDB + AOF)**:  
   - 스냅샷과 로그를 혼합해서 복구 속도와 데이터 안정성을 균형 있게 가져갈 수 있습니다.
```

**꼬리질문**

* Q4-1. RDB와 AOF의 장단점 비교?

```text
RDB는 빠르고 백업 파일이 작지만, 스냅샷 사이에 쓰인 데이터는 유실될 수 있습니다.  
AOF는 거의 실시간으로 로그를 남기기 때문에 데이터 유실이 적지만,  
파일이 커지고 복구 속도가 느린 것이 단점입니다.

실무에서는 보통 RDB + AOF를 같이 켜서,  
스냅샷으로 빠른 복구를 하고 AOF로 마지막 기록을 보완합니다.
```

* Q4-2. Redis 복제(Replication) 방식은?

```text
Redis는 Master-Replica 구조로 복제를 합니다.  
Master 1개에 Replica를 하나 두는 1:1 구조도 가능하고,  
읽기 부하 분산이나 지리적 분산을 위해 여러 개 Replica를 두는 1:N 구조도 지원합니다.  

Master에서 데이터를 쓰면 Replica가 거의 실시간으로 데이터를 복제합니다.  
복제의 장점은 네 가지로 정리할 수 있습니다.

1. **고가용성(High Availability)**  
   - Master 장애 시 Replica를 승격해 서비스 복구가 가능합니다.  

2. **읽기 부하 분산(Read Scaling)**  
   - 조회 트래픽을 Replica로 분산해 Master 부하를 줄일 수 있습니다.  

3. **백업 및 데이터 보존**  
   - Replica에서 RDB나 AOF를 생성해 백업을 남길 수 있습니다.  

4. **지리적 분산(Geo-Replication)**  
   - 글로벌 서비스에서 지역별 Replica를 두어 지연을 줄이고 장애 시 데이터 보호에 유리합니다.  

다만 Redis 복제는 **비동기**로 이루어지기 때문에,  
Replica 지연(lag)이 생길 수 있고 장애 시점에 복제되지 않은 데이터는 유실될 가능성이 있습니다.
```

* Q4-3. Redis 복제가 비동기로 이루어진다는 게 무슨 뜻인가요?
```text
Redis의 Master→Replica 복제는 비동기 방식으로 동작합니다.
Master에서 쓰기 명령어를 처리하고 나면, 그 결과를 Replica로 전송하지만,
Replica가 반영할 때까지 Master는 기다리지 않고 바로 다음 요청을 처리합니다.
그래서 쓰기 성능은 빠르지만, Replica가 항상 즉시 최신 상태를 보장하지는 않습니다.
```

* Q4-4. 복제 지연(Replication Lag)은 무엇이고, 왜 발생하나요?
```text
Replication Lag은 Master에서 데이터를 쓰고 나서 Replica가 그 데이터를 반영하기까지의 시간 차이를 말합니다.
주로 네트워크 지연, Replica 서버 성능 부족, 또는 대량의 쓰기 트래픽 때문에 발생합니다.
예를 들어 Master는 초당 수만 건의 요청을 처리하는데, Replica가 그 속도를 따라가지 못하면 Lag이 쌓이게 됩니다.
```

* Q4-5. Lag이 발생하면 어떤 문제가 있나요?
```text
Replica는 주로 읽기 전용 트래픽을 분산시키는데 사용하잖아요.
Lag이 생기면 Replica에서 조회할 때 최신 데이터가 아닌 과거 데이터를 볼 수 있어서
읽기 일관성이 깨집니다.
그래서 실시간성이 중요한 서비스에서는 문제가 됩니다.
```

* Q4-6. Redis Sentinel과 Cluster 차이는 무엇인가요?
```text
Sentinel은 단일 Master 기반으로 Failover만 제공하고,  
Cluster는 샤딩+Failover까지 제공해 확장성과 가용성을 모두 확보합니다.
Sentinel은 데이터 분산 처리 불가, Cluster는 데이터 샤딩까지 제공.
```


---

## 5️⃣ 성능 & 트러블슈팅

**Q5. Redis 성능 최적화를 위해 어떤 기법을 사용하나요?**

```text
Redis는 In-Memory 구조라 기본적으로 빠르지만, 
운영 환경에서 잘못 사용하면 금방 병목이 생길 수 있기 때문에 
주요 성능 최적화 기법을 적용하는 것이 중요합니다.

1. **Pipeline**  
   여러 명령어를 모아서 한 번에 서버로 보내고, 응답도 한 번에 받아 
   네트워크 왕복 횟수를 최소화합니다.

2. **Lua Script**  
   GET → 조건 확인 → SET 같은 연속적인 로직을 서버에서 원자적으로 처리해  
   Race Condition과 불필요한 네트워크 왕복을 방지합니다.

3. **블로킹 명령어 회피**  
   KEYS, SMEMBERS처럼 O(N) 블로킹 명령어는 데이터가 많을 때 Redis를 멈추게 할 수 있어  
   SCAN, SSCAN 같은 점진적 탐색 명령으로 대체합니다.

4. **TTL과 Eviction 정책**  
   maxmemory와 allkeys-lru 같은 정책으로 메모리를 관리하고,  
   TTL 만료 시간을 랜덤 오프셋으로 분산해 TTL Storm을 방지합니다.

5. **Slowlog 기반 모니터링**  
   SLOWLOG로 느린 명령을 분석해 병목을 확인하고,  
   예를 들어 KEYS를 SCAN으로 바꿔 성능을 개선하는 식으로 대응합니다.
```

**꼬리질문**

* Q5-1. KEYS 명령어를 사용하면 어떤 문제가 발생하나요?
```text
KEYS 명령어는 O(N) 연산이라 데이터가 수십만~수백만 개일 때 Redis 전체를 블로킹할 수 있습니다.
이럴 땐 응답이 몇 초씩 지연되거나 CPU 사용량이 급격히 올라갑니다.

운영 환경에서는 KEYS 대신 SCAN을 사용합니다.
SCAN은 한 번에 일부 키만 반환하고 커서를 유지하기 때문에
점진적으로 탐색하면서 Redis를 블로킹하지 않습니다.
```

* Q5-2. Pipeline과 Transaction의 차이는 무엇인가요?
```text
Pipeline은 여러 명령을 모아서 네트워크 왕복을 줄이는 기법이고,  
Transaction(MULTI/EXEC)은 명령어들을 원자적으로 실행하는 데 초점이 있습니다.  
두 기능을 같이 쓰기도 하지만 목적이 다릅니다.
```

* Q5-3. Cache Stampede 문제는 어떻게 해결하나요?

```text
Cache Stampede는 캐시가 만료될 때 여러 요청이 동시에 DB를 조회하면서
순간적으로 DB 부하가 폭증하는 문제를 말합니다.

보통 세 가지 방법으로 방지합니다.

1. 분산 락(SetNX + TTL)  
   - 첫 요청만 DB를 조회하고 캐시에 넣도록 락을 걸어줍니다.
2. TTL에 랜덤 오프셋 추가  
   - 키마다 만료 시간을 조금씩 다르게 해서 한꺼번에 캐시가 날아가는 걸 방지합니다.
3. 백그라운드 리프레시  
   - TTL이 임박하면 백그라운드에서 캐시를 미리 갱신해둡니다.
```

* Q5-4. Redis를 캐시로 사용할 때 전략은 무엇인가요?
```text
Redis를 캐시로 쓸 때는 데이터 일관성과 성능을 모두 고려해야 합니다.
대표적으로 세 가지 전략을 씁니다.

1. Cache-Aside (Lazy Loading)  
   - 읽을 때 캐시를 먼저 보고, 없으면 DB에서 읽어서 캐시에 넣습니다.
   - 단순하고 많이 쓰이는 방식이지만 Cache Miss 시 DB 부하가 걸립니다.

2. Write-Through  
   - 쓰기 시점에 DB와 캐시를 동시에 갱신합니다.
   - 항상 최신 데이터지만, 쓰기 부하가 늘어납니다.

3. Write-Behind  
   - 캐시만 먼저 갱신하고 DB는 비동기로 기록합니다.
   - 성능은 좋지만, 장애 시 데이터 유실 위험이 있습니다.
```

* Q5-5.캐시 무효화(Cache Invalidation)는 어떻게 하나요?
```text
캐시 무효화는 세 가지 방법으로 합니다.

1. TTL 기반 자동 만료  
   - 예: 5분 TTL을 걸면 오래된 데이터는 자동 삭제됩니다.

2. DB 변경 시 명시적 삭제  
   - 데이터가 바뀌면 관련 캐시를 바로 지워서, 다음 요청 때 새로 갱신합니다.

3. 패턴 기반 삭제  
   - 여러 키를 한 번에 지울 때는 KEYS 대신 SCAN + DEL을 사용해 점진적으로 삭제합니다.
```

* Q5-6. Hot Key 문제를 어떻게 대응하나요?
```text
Hot Key는 특정 키에 트래픽이 몰려 Redis나 네트워크에 병목이 생기는 문제입니다.

대응 방법은 보통 세 가지입니다.

1. Key 샤딩  
   - 예: key:1 → key:1:0, key:1:1 … 로 쪼개서 분산 처리

2. 로컬 캐시 추가  
   - 서버 내부 LRU 캐시를 두고 Redis 접근을 줄입니다.

3. Lua Script 활용  
   - 여러 연산을 서버에서 한 번에 처리해 네트워크 왕복을 줄입니다.
```

* Q5-7. TTL Storm과 Cache Stampede 차이는 무엇인가요?
```text
둘 다 캐시 만료와 관련된 문제지만, 원인과 영향/맥락이 다릅니다.

- **TTL Storm**  
  동시에 많은 키가 만료되면서 Redis CPU 사용량이 순간적으로 튀고  
  응답이 느려지는 현상 (CPU spike)  
  주로 Active Expiration 스캔과 맞물려 발생합니다.

- **Cache Stampede**  
  만료된 캐시를 여러 요청이 동시에 조회하면서  
  DB 부하가 폭증하는 현상입니다.  
  주로 읽기 트래픽에서 문제가 됩니다.

정리하면, TTL Storm은 Redis 자체의 부하 문제고  
Cache Stampede는 DB 부하 문제라고 보면 됩니다.
```

* Q5-8. Redis 성능 모니터링은 어떻게 하나요?
```text 
INFO, SLOWLOG GET, MONITOR 같은 명령어로 상태를 확인합니다.  
SLOWLOG로 느린 쿼리를 확인하고, KEYS 사용 같은 병목을 찾아서 SCAN으로 교체하는 식으로 개선합니다.
```

---

## 6️⃣ 분산 락

**Q6. Redis로 분산 락이 왜 필요하고, 분산 락을 구현하는 방법을 설명해주세요.**

```text
Redis는 싱글 스레드라 단일 인스턴스에서는 동시 접근 문제가 크게 없지만,
멀티 서버나 워커 여러 개가 동시에 같은 자원(예: 주문 처리, 큐 작업)에 접근하면
같은 작업을 중복 실행할 수 있습니다. 
이런 중복 처리를 막으려면 뮤텍스, 즉 **분산 락**이 필요합니다.

분산 락을 Redis로 구현할 때는 세 가지 포인트를 기억합니다.

1. **락 획득 (SET NX EX)**  
   - `SET lock_key unique_id NX EX 5` 이런 식으로 설정합니다.  
   - NX는 키가 없을 때만 생성, EX는 TTL(예: 5초)을 걸어 자동 만료되게 해서
     락이 영원히 남아 데드락 되는 걸 방지합니다.

2. **락 해제 (Lua Script)**  
   - 단순 DEL은 위험합니다. 락이 만료된 직후 다른 프로세스가 락을 잡았을 수도 있는데
     내가 실수로 지워버리면 Race Condition이 발생합니다.  
   - 그래서 Lua Script로 `GET → 내가 잡은 락인지 확인 → DEL` 순서를
     원자적으로 실행합니다.

3. **TTL 설정으로 Deadlock 방지**  
   - 락을 잡은 프로세스가 장애로 죽어도 TTL이 지나면 자동으로 풀리게 합니다.
```

**꼬리질문**

* Q6-1. Race Condition 방지법은?

```text
Lua Script로 GET과 DEL을 묶어서 원자적으로 실행합니다.
먼저 락의 소유자 ID를 확인하고, 내가 잡은 락이 맞으면 DEL을 해서
다른 프로세스 락을 실수로 지우지 않도록 합니다.
```

* Q6-2. Redlock은 언제 필요한가요?

```text
Redlock은 멀티 인스턴스 환경에서 락의 신뢰성을 높일 때 필요합니다.

단일 Redis로도 락을 구현할 수 있지만,
만약 Redis 인스턴스 자체에 장애가 나면 락이 풀려버리거나
잘못된 상태로 남을 수 있습니다.

Redlock은 여러 Redis 인스턴스에 동시에 락을 시도해서
과반수 이상 성공하면 락을 획득했다고 판단합니다.
이렇게 하면 한두 개 인스턴스에 장애가 나도
락의 안전성을 보장할 수 있어서 고가용성 환경에서 유리합니다.

그래서 일반적인 단일 인스턴스 환경에서는 Redlock까지는 필요 없고,
멀티 인스턴스나 분산 환경에서만 고려합니다.
```


--- 
<details>
<summary>cf. reference</summary>

- https://jaehyuuk.tistory.com/216
- https://sunro1994.tistory.com/333#Redis%EB%A5%BC%20%ED%99%9C%EC%9A%A9%ED%95%98%EC%97%AC%20%EC%84%B8%EC%85%98%20%EC%A0%80%EC%9E%A5%EC%86%8C%EB%A1%9C%20%EC%82%AC%EC%9A%A9%ED%95%A0%20%EA%B2%BD%EC%9A%B0%EC%9D%98%20%EC%9E%A5%EC%A0%90%EA%B3%BC%20%EB%8B%A8%EC%A0%90%EC%9D%80%20%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94%3F-1-33

- [NHN FORWARD 2021](https://www.youtube.com/watch?v=92NizoBL4uA)
</details>