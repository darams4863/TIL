---
title: "Redis 영속성과 복제"
date: 2025-07-31
categories:
  - redis
tags:
  - redis
  - persistence
  - RDB/AOF
  - replication
  - sentinel 
  - cluster 
  - HA 
---

# Redis 영속성과 복제

## 개요
Redis는 인메모리 DB이지만 메모리 데이터를 디스크에 저장할 수 있어 서버 재시작 후에도 데이터가 유지된다. 이 영속성 기능은 데이터 스토어로서의 활용을 가능하게 하지만, 잘못 사용하면 장애의 원인이 될 수 있다.

Redis에서는 두 가지 영속성 방식을 제공합니다:
- **RDB (Snapshotting)**: 특정 시점의 메모리 데이터 전체를 디스크에 저장
- **AOF (Append Only File)**: 모든 쓰기 명령을 순차적으로 기록

## 1. Redis Persistence (영속성)

### 1.1 RDB (Redis Database)

#### 기본 개념
- **스냅샷 기반 백업**: 특정 시점의 메모리 상태를 바이너리 파일로 저장
- **자동 저장**: 기본적으로 `dump.rdb` 파일에 자동 저장
- **압축 저장**: 바이너리 형태로 압축되어 파일 크기가 작음

=> RDB(snapshot)은 일정 시점의 메모리 데이터를 스냅샷을 떠서 디스크에 저장하는 방식입니다.
(cf. 스냅샷을 뜬다는 말은 특정 시점의 메모리에 있는 데이터를 바이너리 파일로 저장하는 뜻입니다)
직접 세팅을 하지 않더라도 Redis는 자동으로 .rdb(cf. dump.rdb)라는 확장자의 파일에 인메모리 데이터를 저장하도록 디폴트 설정이 되어 있습니다.

#### RDB 장단점
**장점:**
- 빠른 복구 속도 && 작은 파일 크기
  - 바이너리 형태로 압축되어 저장되어 파일의 크기가 작다 → 백업/복구가 빠르다
- 백업 파일 전송 효율적
- 메인 프로세스 작업 방해 없음

**단점:**
- 스냅샷 사이에 발생한 데이터는 유실 가능성이 있다
- Fork 시 메모리 사용량 2배 증가 -> 잠깐의 latency spike 가능
- 저장 중 성능 저하 (Latency Spike)


#### RDB 트리거 조건
```bash
# redis.conf 설정
save 900 1      # 900초(15분) 동안 1개 이상 키 변경 시
save 300 10     # 300초(5분) 동안 10개 이상 키 변경 시  
save 60 10000   # 60초 동안 10000개 이상 키 변경 시
```

#### RDB 저장 과정
1. **Fork 발생**: 자식 프로세스 생성
2. **메모리 복사**: Copy-on-Write로 메모리 페이지 복사
3. **디스크 쓰기**: 자식 프로세스가 디스크에 저장
4. **원본 교체**: 저장 완료 후 원본 파일 교체

#### Fork 메커니즘
- **Fork**: Unix/Linux 시스템에서 부모 프로세스가 자식 프로세스를 생성하는 시스템 콜
- **Copy-on-Write (CoW)**: 메모리 페이지를 실제로 수정할 때만 복사하는 기술
- **목적**: 백업 작업을 별도 프로세스에서 수행하여 메인 서비스에 영향 최소화

#### Fork 동작 과정
```bash
# 1. Fork 발생 전: 단일 프로세스
Redis 메인 프로세스 (메모리: 1GB)

# 2. Fork 발생 후: 부모-자식 프로세스
Redis 메인 프로세스 (원본)     Redis 자식 프로세스 (복사본)
├── 메모리: 1GB 사용           ├── 메모리: 1GB 사용
└── 데이터: 키-값 쌍들          └── 데이터: 키-값 쌍들 (동일)

# 3. 데이터 수정 시: Copy-on-Write
Redis 메인 프로세스 (수정된 데이터)     Redis 자식 프로세스 (원본 유지)
```

#### RDB 최적화 방법
- **메모리 모니터링**: 메모리 사용량 지속적 확인
- **저장 시점 조정**: 트래픽이 적은 시간대에 저장
- **압축 설정**: RDB 파일 압축으로 크기 최소화
- **에러 처리**: 백그라운드 저장 실패 시 쓰기 중단 설정

### 1.2 AOF (Append Only File)
#### 기본 개념
- **명령어 로그**: 모든 쓰기 명령을 순차적으로 기록
- **실시간 백업**: 명령어 단위로 실시간 기록
- **재실행 복구**: 저장된 명령어를 재실행하여 복구
  => AOF(Append On File) 방식은 redis의 모든 write/update 연산 자체를 모두 log 파일에 기록하는 방식이다. default로 appendonly.aof 파일에 기록되며, 조회를 제외한 입력/수정/삭제 명령이 실행될 때 마다 기록된다. 그리고 서버가 재시작될 때, log에 기록된 write/update 연산을 재 실행하는 형태로 데이터를 복구하는 방식이다. 

#### AOF 장단점
**장점:**
- 거의 실시간에 가까운 백업 -> 최소한의 데이터 유실
- 재시작 시 AOF 재생으로 빠른 복구 가능 

**단점:**
- 모든 write/update 연산을 log 파일에 남기기 때문에 데이터 양이 크다 
- 지속적으로 연산을 적기 때문에 지속적인 디스크 I/O가 발생한다 
- 복구시 저장된 모든 연산을 다시 실행하기 때문에 복구 속도가 느리다 

**AOF 단점 보완:**
- AOF는 모든 쓰기 명령을 로그 파일에 기록하는데, 여기서 성능 vs 안전성의 딜레마가 발생한다: 
  - 문제상황 1: 
    - Redis가 명령어를 AOF 파일에 기록할 때, 실제로는 메모리 버퍼에만 기록됨
    - 운영체제가 나중에 디스크에 실제로 저장하는데, 이때 서버 장애가 발생하면?
      → 메모리 버퍼의 데이터가 유실됨!
    - 이때 등장하는 개념이 `fsync 옵션`
      - 핵심 목적: **데이터 유실 방지**. 메모리 버퍼의 데이터를 즉시 디스크에 저장 
      - 문제 해결: 서버 장애 시 메모리 버퍼의 데이터 유실 방지
      - 결과: 안전성 향상 (데이터 유실 최소화)
  - 문제상황 2: 
    - AOF는 모든 명령어를 순차적으로 기록하기 때문에 **파일이 계속 커지는** 문제가 발생
    - 예시: 같은 키에 대한 중복된 명령어들이 쌓임
      ```
      SET user:1 "John"
      SET user:1 "John Doe"     # 같은 키를 여러 번 수정
      SET user:1 "John Doe Smith"
      DEL user:1
      SET user:1 "New User"     # 삭제 후 다시 생성
      ```
    - **문제점:**
      - 같은 키에 대한 중복된 명령어들이 쌓임
      - 파일 크기가 계속 증가 (디스크 공간 부족)
      - 복구 시 불필요한 명령어들도 모두 실행 (복구 시간 오래 걸림)
    - 이때 등장하는 개념이 `AOF rewrite` 
      - 핵심 목적: **복구 성능 향상**. AOF 파일 크기 축소 및 중복 명령어 제거
      - 문제 해결: 파일이 계속 커져서 복구 시간이 오래 걸리는 문제
      - 결과: 성능 향상 (복구 속도 개선)
      - **동작 방식**: 현재 메모리 상태를 기반으로 최소한의 명령어로 재생성
        ```
        # Rewrite 전: 200KB
        SET user:1 "John"
        SET user:1 "John Doe"
        SET user:1 "John Doe Smith"
        DEL user:1
        SET user:1 "New User"
        
        # Rewrite 후: 50KB (75% 축소!)
        SET user:1 "New User"  # 최종 상태만
        ```

      
#### fsync 메커니즘 (데이터 유실 방지) 
- **fsync**: 파일 시스템 동기화 함수로, 메모리 버퍼의 데이터를 실제 디스크에 강제로 쓰는 작업
- **목적**: 메모리에 있는 데이터를 디스크에 물리적으로 저장하여 장애 시 데이터 유실 방지

#### 데이터 저장 과정
```bash
# 1. Redis 명령어 실행
SET user:1000 "John Doe"

# 2. 메모리 버퍼에 기록
Redis 메모리 → OS 파일 버퍼 → AOF 파일 (메모리상)

# 3. fsync 실행 (appendfsync everysec)
OS 파일 버퍼 → 실제 디스크 저장

# 4. 장애 발생 시
서버 재시작 → AOF 파일에서 명령어 재실행 → 데이터 복구
```

#### AOF fsync 모드
```bash
# redis.conf 설정
appendfsync always    # 매 명령어마다 fsync (안전하지만 느림)
appendfsync everysec  # 1초마다 fsync (권장, 안전성과 성능 균형)
appendfsync no        # OS가 결정 (빠르지만 데이터 유실 위험)
```

#### fsync 모드별 특징
**appendfsync always**
- **동작**: 매 명령어마다 fsync 실행
- **장점**: 데이터 유실 최소화 (최대 1개 명령어 유실)
- **단점**: 성능 저하 (매번 디스크 I/O 발생)
- **사용**: 금융, 결제 등 데이터 정확성이 중요한 시스템

**appendfsync everysec**
- **동작**: 1초마다 fsync 실행
- **장점**: 안전성과 성능의 균형
- **단점**: 최대 1초간 데이터 유실 가능
- **사용**: 대부분의 웹 서비스 (권장 설정)

**appendfsync no**
- **동작**: OS가 자동으로 fsync 실행 (보통 30초)
- **장점**: 최고 성능
- **단점**: 최대 30초간 데이터 유실 가능
- **사용**: 캐시 용도, 데이터 유실 허용 가능한 시스템

#### AOF Rewrite
- **목적**: AOF 파일 크기 축소 및 복구 속도 향상
- **방식**: 현재 메모리 상태를 기반으로 최소 명령어로 재생성
- **트리거**: `auto-aof-rewrite-percentage 100` (100% 증가 시)

#### AOF 최적화 방법
```bash
# 1. 디스크 성능 확인
iostat -x 1

# 2. AOF 파일 위치 최적화
# SSD 사용 권장, 다른 프로세스와 디스크 분리

# 3. 파일 시스템 최적화
# ext4, xfs 등 고성능 파일 시스템 사용

# 4. AOF Rewrite 최적화
auto-aof-rewrite-percentage 100
auto-aof-rewrite-min-size 64mb
```


### 1.3 Mixed Mode (RDB + AOF)
- 위의 두 방법을 섞어서 사용하는 방법도 있다 (권장). 
  - RDB + AOF 병행:
    - RDB를 주기적 스냅샷으로 사용하여 빠른 복구 보장
    - AOF를 변경 로그 보조 기록으로 사용해 스냅샷과 스냅샷 사이의 데이터 유실 방지
    - 빠른 재시작 + 안정성 확보


#### 데이터 유실 시나리오
- **RDB**: 스냅샷 사이에 발생한 데이터는 유실 가능
- **AOF**: fsync 설정에 따라 데이터 유실 가능 (cf. fsync 설정: always, no)

-> **Mixed Mode**: RDB + AOF 조합으로 데이터 유실 최소화  

#### 동작 방식
1. **AOF 파일 구조**: RDB 헤더 + AOF 명령어들
2. **복구 과정**: RDB 부분 먼저 로드 후 AOF 명령어 재실행
3. **장점**: 빠른 복구 + 최소 데이터 유실

#### 설정 방법
```bash
# redis.conf
# 1) RDB 스냅샷
save 900 1      # 15분 동안 1개 이상의 key 변경 시 RDB 저장
save 300 10     # 5분 동안 10개 이상의 key 변경 시 RDB 저장
save 60 10000   # 1분 동안 10000개 이상의 key 변경 시 RDB 저장

# 2) AOF 활성화
appendonly yes
appendfsync everysec   # 성능과 안정성 균형

# 3) AOF 재작성 (압축)
auto-aof-rewrite-percentage 100
auto-aof-rewrite-min-size 64mb
```

---
---

## 2. Redis Replication (복제)
- 복제란 레디스의 데이터를 거의 실시간으로 다른 레디스 노드에 복사하는 작업이다. 원본을 Master라고, 복제본 노드를 Replica라고 한다.
  - 마스터-슬레이브 구조(Master-Replica 구조) 기반
  - 마스터(Master) → 복제본(Replica, 구버전 용어: Slave)으로 데이터 전송 
  - 다중 슬레이브 구성이 가능하다 
  - Redis Cluster와 달리 샤딩은 없음, 모든 Replica는 마스터 데이터를 그대로 복사
- 복제 사용 이유/목적: 
  - **고가용성 (High Availability)**
    - Redis는 단일 프로세스 구조라서 Master 다운시 읽기/쓰기 불가 -> Replica를 두면 장애시 Failover(장애 전환) 가능 
      - 예: Redis Sentinel, Redis Cluster
      - 예: EC2 한 대에서 Master 죽으면, Replica를 Promote해서 바로 Master로 승격
  - **읽기 부하 분산 (Read Scaling)** 
    - Master는 쓰기 중심, Replica는 읽기 전용으로 활용 가능
    - 고트래픽 API 서버에서 Redis 읽기 부하를 Replica로 분산 가능
      - 예: 랭킹 조회, 실시간 피드 조회는 Replica, 쓰기/업데이트는 Master
  - **백업 및 데이터 보존** 
    - Replica는 Master의 복제본이므로 백업 용도로 활용 가능 -> Master에 부하 없이 Replica에서 RDB/AOF 생성 가능
    - 예: 운영 서버 Replica에서 정기 스냅샷 떠서 S3 업로드
  - **지리적 분산 (Geo-Replication)** 
    - 글로벌 서비스에서 지연 시간 최소화
      - 한국 Master → 일본/미국 Replica
      - 현지 사용자는 Replica에서 읽기
    - 네트워크 장애 시 데이터 유실 방지에도 도움
- 정리: 
  |목적|설명|
  |:---:|:---:|
  |고가용성|장애 시 Replica를 Master로 승격 (Failover)|
  |읽기 부하 분산|읽기 전용 Replica로 트래픽 분산|
  |백업/보존|Replica에서 스냅샷 떠서 백업|
  |지리적 분산|글로벌 서비스에서 지연 최소화|


### 2.1 기본 복제 구조
#### Master-Slave (Replica) 구조
```bash
# Master 설정
bind 0.0.0.0
port 6379

# Slave 설정
replicaof 192.168.1.100 6379
replica-read-only yes
```

#### 복제 과정
**1단계: 연결 수립**
- Slave가 Master에 연결 시도 및 연결 확인

**2단계: 인증 및 정보 교환**
- 필요시 인증 수행
- 복제 정보 및 기능 교환

**3단계: 동기화 방식 결정**
- 전체 동기화: RDB 스냅샷 전송
- 부분 동기화: 누락된 명령어만 전송

**4단계: 실시간 복제 시작**
- 이후 모든 쓰기 명령을 실시간으로 전파

#### 복제 과정 시각화
```
시간축: ─────────────────────────────────────────────→

Master:  [초기 데이터] ──[RDB 생성]───[실시간 명령 전파]───
         │              │            │
         │              │            ├─ SET user:1 "John"
         │              │            ├─ SET user:2 "Jane"  
         │              │            └─ DEL user:1
         │              │
Slave:   [연결 시도] ──[RDB 수신]───[실시간 명령 수신]───
         │            │            │
         │            │            ├─ SET user:1 "John"
         │            │            ├─ SET user:2 "Jane"
         │            │            └─ DEL user:1
         │            │
         └─ 연결 수립  └─ 데이터 동기화 └─ 실시간 복제
```


### 2.2 복제 모드
#### 전체 동기화 (Full Resynchronization)
- **조건**: 
  - Slave가 Master의 replication ID를 모르는 경우 (첫 연결)
  - Slave의 offset이 Master의 replication backlog 범위 밖인 경우
  - 네트워크 장애로 인해 오랫동안 연결이 끊어진 경우

- **과정**: 
  1. Master가 RDB 스냅샷 생성 (Fork 발생)
  2. RDB 파일을 Slave로 전송 (네트워크 대역폭 소모)
  3. Slave가 RDB 파일을 디스크에 저장
  4. Slave가 RDB 파일을 메모리에 로드
  5. 실시간 복제 시작

- **단점**: 
  - 대용량 데이터 시 시간 소요 (수 GB 데이터 시 수 분 소요)
  - Fork로 인한 Master 성능 저하
  - 네트워크 대역폭 대량 소모

#### 부분 동기화 (Partial Resynchronization)
- **조건**: 
  - Slave가 Master의 replication ID를 알고 있음
  - Slave의 offset이 Master의 replication backlog 범위 내에 있음
  - 일시적인 네트워크 장애 후 재연결

- **과정**: 
  1. Slave가 PSYNC 요청 시 replication ID와 offset 전송
  2. Master가 backlog에서 해당 offset 이후의 명령어들 확인
  3. 누락된 명령어들만 Slave로 전송
  4. 실시간 복제 재개

- **장점**: 
  - 빠른 재연결 (수 초 내 완료)
  - 네트워크 대역폭 절약
  - Master 성능 영향 최소화

#### 복제 백로그 (Replication Backlog)
- **목적**: 일시적 네트워크 장애 후 빠른 재연결을 위한 명령어 버퍼
- **동작**: Master가 최근 명령어들을 메모리에 임시 저장
- **장점**: 전체 동기화 없이 누락된 명령어만 전송 가능

- **실무 주의사항**:
  - 백로그 크기가 작으면 네트워크 단절 시 전체 재복제 발생 → Master 부하 급증
  - 복제 스톨(Replication backlog 초과) 시 Full Resync 필요 → 성능 저하

#### 동기화 방식 결정 과정
```
Slave 재연결 시도
        │
        ▼
PSYNC 요청 전송
        │
        ▼
Master가 조건 확인
        │
        ├─ replication ID 일치? ── NO ──→ 전체 동기화
        │
        ├─ offset이 backlog 범위 내? ── NO ──→ 전체 동기화
        │
        └─ YES ──→ 부분 동기화
```

### 2.3 복제 설정 옵션

#### 복제 설정 옵션
- **백로그 크기**: 부분 동기화를 위한 명령어 버퍼 크기
- **타임아웃**: 복제 연결 타임아웃 설정
- **읽기 전용**: Slave의 읽기 전용 모드 설정
- **복제 지연 허용**: 일정 지연까지 허용하는 설정

### 2.4 복제 모니터링

#### 복제 상태 확인
- **복제 정보**: Master-Slave 연결 상태 및 지연 확인
- **복제 지연**: 네트워크 지연으로 인한 데이터 동기화 지연 모니터링
- **연결 상태**: 각 노드의 역할(Master/Slave) 확인

#### 복제 지연 (Replication Lag)
- **원인**: 네트워크 지연, Slave 성능 부족
- **영향**: 읽기 일관성 문제
- **해결**: 네트워크 최적화, Slave 성능 향상

## 3. Redis Sentinel
- Redis 는 단일 인스턴스로도 운영 가능하지만 물리 머신이 가진 메모리의 한계를 초과하는 데이터를 저장하고 싶거나, failover에 대한 처리를 통해 HA(=고가용성)를 보장하려면 Sentinel이나 Cluster 등의 운영 방식을 선택해서 사용해야 한다
- Master 노드 장애시 Slave를 Master를 승격시켜야 하는데, 이때 자동으로 승격하지 않기 떄문에 Redis Sentinel을 활용한다
- Redis Sentinel 은 장애 발생시 운영 서비스에 영향 없도록(=고가용성) 레디스 마스터 모니터링 및 자동 장애 극복 조치 (=Fail-over) 해주는 서비스 
(cf. Redis Sentinel은 단독으로 HA를 만드는게 아니라, 복제(Replication)구조와 Failover 관리를 결합해서 고가용성을 제공하는 방식이다)

### 3.1 Sentinel 구조
- **목적**: 
  - 모니터링(Monitoring) : Master/Slave 제대로 동작하는지 지속적으로 감시
  - 자동 장애 조치(Automatic Failover) 
  - 알림(Notification) : failover되었을 때 pub/sub으로 client에게 알리거나, shell script로 이메일이나 sms를 보낼 수 있다
  => 자동 장애 감지 및 페일오버, 알림 기능
- **구성**: 홀수 개의 Sentinel 노드 (최소 3개)
- **동작**: Master 모니터링 → 장애 감지 → 페일오버 실행

### 3.2 Sentinel 설정
- **모니터링 대상**: Master 노드 정보 설정
- **장애 감지 시간**: 연결 실패 후 장애로 판단하는 시간
- **페일오버 타임아웃**: 페일오버 완료 대기 시간
- **동시 동기화**: 페일오버 후 동시에 복제할 Slave 수

### 3.3 페일오버 과정
1. **장애 감지**: Sentinel들이 Master를 지속적으로 감시하며 연결 성공/실패 확인
2. **합의 도출**: 과반수 Sentinel이 장애 인정
3. **새 Master 선출**: 가장 적합한 Slave 선택
4. **설정 업데이트**: 다른 Slave들의 복제 대상 변경
5. **클라이언트 알림**: 새로운 Master 정보 전파. Master로 승격, 기존의 Master는 Slave로 강등시킨다 

## 4. Redis Cluster
- Redis Cluster는 수평적 확장성(Scale-out)과 고가용성(HA)을 동시에 제공하는 분산 Redis 솔루션이다
- 단일 Redis 인스턴스의 메모리 한계를 극복하거나, 대용량 데이터를 여러 노드에 분산 저장하고 싶을 때 사용한다
- Sentinel과 달리 샤딩(Sharding)을 통해 데이터를 여러 노드에 분산 저장하며, 각 노드는 전체 데이터의 일부만 관리한다 (cf. 해시 슬롯)
- 자체적인 장애 감지 및 페일오버 기능을 내장하고 있어 별도의 Sentinel 서비스 없이도 고가용성을 보장한다
(cf. Redis Cluster는 샤딩 + 복제 + 자동 페일오버를 결합하여 확장성과 고가용성을 동시에 제공하는 방식이다)

### 4.1 클러스터 구조
- **샤딩**: 16384개의 해시 슬롯으로 데이터 분산
  - 해시 슬롯: Redis 클러스터에서 데이터를 논리적으로 분산하는 단위 (cf. 2^14 -> 14비트로 슬롯 정보를 표현하기 때문에 16384개)
  - 각 슬롯은 특정 Master 노드가 관리
- **노드**: Master-Slave 쌍으로 구성
  - 각 Master 노드는 일부 슬롯을 담당
  - 각 Master는 최소 1개의 Replica를 가져야 함 (고가용성 보장)
  - Master 장애 시 Replica가 자동으로 승격
- **라우팅**: 클라이언트가 직접 적절한 노드로 요청
  - 클라이언트가 슬롯-노드 매핑 정보를 캐시
  - 키의 슬롯을 계산하여 해당 노드로 직접 요청
  - 잘못된 노드로 요청 시 MOVED 에러와 함께 올바른 노드 정보 반환

### 4.2 해시 슬롯
```python
# 해시 슬롯 계산
def get_hash_slot(key):
    return crc16(key) % 16384

# 예시
slot = get_hash_slot("user:1000")  # 특정 슬롯 번호 반환
```

### 4.3 클러스터 명령어 제약
```bash
# 단일 슬롯 명령어 (정상 동작)
SET key value
GET key

# 다중 슬롯 명령어 (에러 발생)
MGET key1 key2 key3  # 서로 다른 슬롯에 있을 수 있음
MSET key1 val1 key2 val2

# 해결 방법: 파이프라인 사용
pipeline = redis_cluster.pipeline()
pipeline.get("key1")
pipeline.get("key2")
pipeline.execute()
```

### 4.4 클러스터 장애 대응
- **자동 페일오버**: Master 노드 장애 시 Replica가 자동으로 승격
  - 장애 감지: 노드 간 PING/PONG으로 연결 상태 확인
  - 합의 도출: 과반수 노드가 장애 인정
  - Replica 승격: 가장 적합한 Replica를 새 Master로 선출
  - 슬롯 재할당: 장애 노드의 슬롯을 새 Master가 인수
- **부분 장애**: 일부 노드만 장애 시 다른 노드 영향 최소화
  - 장애 노드의 슬롯만 접근 불가
  - 다른 슬롯은 정상적으로 서비스 제공
- **전체 복구**: 클러스터 전체 장애 시 복구 절차
  - 모든 노드의 RDB 파일 확인
  - 클러스터 토폴로지 재구성
  - 슬롯 할당 및 복제 관계 재설정

### 4.5 클러스터 확장 및 축소
- **노드 추가**: 클러스터 확장 시 슬롯 재분배
  - 새 노드 추가 및 슬롯 재분배
  - 기존 노드에서 새 노드로 데이터 마이그레이션
- **노드 제거**: 클러스터 축소 시 슬롯 이전
  - 제거할 노드의 슬롯을 다른 노드로 이전
  - 복제 관계 재설정 후 노드 제거

### 4.6 클러스터 vs Sentinel 비교
| 구분 | Redis Sentinel | Redis Cluster |
|------|---------------|---------------|
| **데이터 분산** | 없음 (전체 복사) | 샤딩 (부분 분산) |
| **확장성** | 읽기 확장만 | 읽기/쓰기 확장 |
| **메모리 사용량** | 전체 데이터 × 노드 수 | 전체 데이터 ÷ 노드 수 |
| **장애 대응** | Master-Replica 페일오버 | 노드별 자동 페일오버 |
| **복잡도** | 간단 | 복잡 |
| **사용 사례** | 고가용성 중시 | 확장성 + 고가용성 |

--- 
--- 

## 5. 실무 고려사항 (면접 대비 정리)
### 5.1 데이터 일관성
- **비동기 복제**: Master-Slave 간 데이터 불일치 가능
- **강제 동기화**: `WAIT` 명령어로 동기화 대기
- **읽기 정책**: 일관성 vs 가용성 선택

> **예시 (내 경험)**  
> - FastAPI + Redis 캐시 구조에서, Master 장애 후 Replica를 승격했더니 최신 데이터 일부가 유실된 적 있음.  
> - RDB 저장 주기가 5분이었는데, 장애 순간 3분 전 데이터는 복구 불가 → **비동기 복제 한계**  
> - 결제 포인트 처리 시에는 `WAIT` 명령어를 통해 최소 1개 Replica 확인 후 응답하도록 설계

> **면접 질문 & 답변**
> - **Q:** Redis Master-Slave 구조에서 데이터 불일치가 발생할 수 있는 이유는?  
> - **A:** 비동기 복제로 인해 Master에서 Commit 직후 장애 시 Replica가 최신 데이터를 받지 못할 수 있습니다.
> ---
> - **Q:** 강한 일관성을 보장하려면 어떻게 해야 하나요?  
> - **A:** `WAIT` 명령어를 사용해 지정된 수의 Replica에 복제가 완료될 때까지 대기합니다.

---

### 5.2 성능 최적화
- **복제 지연 모니터링**: `INFO replication`으로 지연 확인
- **네트워크 최적화**: Master-Slave 간 네트워크 대역폭 확보
- **메모리 관리**: 복제 백로그 크기 적절히 설정

> **예시 (내 경험)**  
> - 실무에서 Redis를 세션 저장소로 활용했는데, 트래픽 급증 시 Replica 응답 지연으로 세션 동기화가 늦어졌음.  
> - `INFO replication`에서 `slave_repl_offset` 차이가 2~3초까지 증가  
> - 해결: 백로그 크기 확대 + 전용 네트워크 확보

> **면접 질문 & 답변**
> - **Q:** 복제 지연이 발생하면 어떤 현상이 생기나요?  
> - **A:** Replica를 통해 읽은 데이터가 최신이 아닐 수 있어, 캐시 미스나 잘못된 응답을 반환할 수 있습니다.
> ---
> - **Q:** 복제 백로그가 너무 작으면 어떤 문제가 발생하나요?  
> - **A:** 네트워크 단절 시 전체 재복제를 유발하여 Master 부하가 급증할 수 있습니다.

---

### 5.3 장애 대응
- **자동 페일오버**: Sentinel/Cluster로 자동 처리
- **수동 복구**: 복제 재구성 및 데이터 동기화
- **백업 전략**: RDB + AOF 조합으로 데이터 보호

> **예시 (내 경험)**  
> - 과거 로그 서버에서 Redis Master 장애 발생 → Sentinel이 자동으로 Replica 승격  
> - 일부 데이터 유실 발생 → 백업 RDB + AOF로 부분 복원 후 동기화  
> - 결제나 포인트 같은 핵심 데이터는 **RDB + AOF + 모니터링** 필수로 운영

> **면접 질문 & 답변**
> - **Q:** Redis Sentinel과 Cluster의 장애 처리 방식 차이는 무엇인가요?  
> - **A:** Sentinel은 단일 Master 기준 자동 승격, Cluster는 샤드 단위로 Replica를 승격합니다.
> ---
> - **Q:** Master 장애 시 데이터 복구 방법은?  
> - **A:** Replica 승격 후 필요 시 RDB/AOF 백업을 통해 유실 데이터 복원합니다.

---

### 5.4 클러스터 특화 고려사항
- **키 설계**: 해시 태그를 활용한 관련 데이터 그룹화
  - 같은 슬롯에 배치하여 트랜잭션 및 다중 키 명령어 사용 가능
  - 예: `user:{1000}:profile`, `user:{1000}:settings`
- **명령어 제약**: 다중 슬롯 명령어 사용 시 주의
  - MGET, MSET 등은 같은 슬롯의 키만 사용 가능
  - 트랜잭션은 단일 슬롯 내에서만 동작
- **네트워크 최적화**: 노드 간 통신 최적화
- **모니터링**: 슬롯 분포 및 부하 상태 모니터링

> **예시 (내 경험)**  
> - Redis Cluster에서 세션과 유저 데이터 샤딩 시,  
>   `user:{id}:*` 패턴으로 키를 설계해 한 슬롯에 묶어서 트랜잭션 가능  
> - MGET/MSET 시 서로 다른 슬롯 키를 잘못 사용해 `CROSSSLOT` 에러를 경험  
> - 클러스터 모니터링 시 `redis-cli --cluster info` 와 `INFO replication` 병행 확인

> **면접 질문 & 답변**
> - **Q:** Redis Cluster에서 멀티키 연산 시 주의할 점은?  
> - **A:** 같은 슬롯에 속한 키만 멀티키 연산 가능하며, 해시태그(`{}`)로 슬롯을 맞춰야 합니다.
> ---
> - **Q:** 클러스터에서 트랜잭션은 어떻게 동작하나요?  
> - **A:** 단일 슬롯 내에서만 지원되며, 다중 슬롯 트랜잭션은 불가능합니다.


---
<details>
  <summary>cf. reference</summary>
  
  - https://inpa.tistory.com/entry/REDIS-%F0%9F%93%9A-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%98%81%EA%B5%AC-%EC%A0%80%EC%9E%A5%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95-%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%9D%98-%EC%98%81%EC%86%8D%EC%84%B1
  - https://co-de.tistory.com/15
  - https://velog.io/@always/Redis-%EC%9A%B4%EC%98%81-%EB%B0%A9%EC%8B%9D-Cluster-vs-Sentinel-%EC%96%B4%EB%96%A4-%EA%B2%83%EC%9D%84-%EC%84%A0%ED%83%9D%ED%95%B4%EC%95%BC-%ED%95%A0%EA%B9%8C

</details>
