---
title: "Redis 소개 및 기본 개념"
date: 2025-07-29
categories:
  - redis
tags:
  - redis
  - database
  - cache
---

# Redis 소개
- Redis는 Remote Dictionary Server의 약자로 키(Key) : 값(Value) 해시 맵과 같은 구조를 가진 NoSQL 데이터베이스입니다. 
- Redis는 인메모리 데이터 구조 저장소로, 다양한 데이터 타입을 지원합니다
- 여기서 인메모리 데이터 구조이다라는 뜻은 데이터가 하드디스크(일반 MySql이나 Oracle과는 다르게, SSD, HDD)에서 데이터를 처리하는 것이 아니라 RAM에 저장된다는 말이고 -> 이는 속도가 마이크로 초에서 밀리초 단위로 향상된다는 의미이다. 대신 서버가 꺼지면 데이터가 날아갈 수 있다는 단점이 있고, 이로 인해 RDB/AOF로 백업하는 것이 필수이다. 추후 다룰 예정.
- 또한 그저 key-value로만 저장하는 것이 아니라, String, List, Set, Hash, Sorted Set와 같은 여러 자료구조를 지원한다. 
    - String → 단순 값
    - List → 큐, 스택
    - Set / Sorted Set → 중복 없는 집합, 랭킹 시스템
    - Hash → JSON 비슷한 구조 (user: {name: “A”, age: 20})
    - Stream → 이벤트 로그, 카프카 비슷하게 사용 가능
=> 이 자료구조 덕분에 캐시 + 큐 + 랭킹 + pub/sub까지 다 가능  
- redis가 NoSQL이라는 말은, key-value 기반으로 일반적인 RDB와는 다르게 테이블도 없고 스키마도 없어서 e.g. alter table을 해줄 필요가 없고, key -> value 형태로 다양한 자료구조를 저장할 수 있기 때문에, RDB처럼 JOIN, 복잡한 트랜잭션은 불가능 하지만 대신 속도와 단순성을 최적화 했다는 특징이 있다. 


## 주요 특징
- **인메모리 저장**: 빠른 읽기/쓰기 성능
- **다양한 데이터 타입**: String, List, Set, Hash, Sorted Set, Stream, Geospatial, HyperLogLog, Bitmap, Bitfield
- **영속성**: RDB, AOF 방식으로 데이터 영속성 보장
- **클러스터링**: 수평적 확장 가능

- 여기서 영속성에 대하여..
  - Redis는 휘발성인 인메모리에 데이터를 저장하기 때문에 데이터를 영구적으로 저장할 수 없다. cache 용도로만 사용한다면 상관없겠지만, 캐시 이외의 용도로 사용한다면 데이터 백업이 필수다. 
  - 이에 Redis는 데이터를 영속화하기 위한 `RDB(Redis Database)`와 `AOF(Append Only File)` 2가지 방법을 제공한다. 
  - RDB: 
    - 설정한 일정 시간 단위로 레디스 DB의 스냅샷을 백업하고, 필요시 특정한 시점의 스냅샷으로 롤백할 수 있다.
  - AOF:
    - 모든 쓰기 작업을 로그 파일에 기록하여 데이터 복구를 보장한다.

## 기본 명령어
- 맥북에서
```bash
// Homebrew로 설치
brew install redis

//  Redis 서버 실행
redis-server

// 다른 터미널에서 클라이언트 접속
redis-cli
```

- Ubuntu에서
```bash 
sudo apt update
sudo apt install redis-server -y

// Redis 서버 시작
sudo systemctl start redis-server

// 부팅 시 자동 시작 설정
sudo systemctl enable redis-server

// 동작 확인
redis-cli ping
// → PONG
``` 

- Docker에서
```bash 
// 단일 컨테이너 실행 (-d 백그라운드 실행, -p 6379:6379 : 호스트 6379 포트와 컨테이너 6379 포트 연결)
docker run -d --name my-redis -p 6379:6379 redis

// 컨테이너 내부에서 redis-cli 실행
docker exec -it my-redis redis-cli
``` 


## 레디스가 싱글 스레드 모델임에도 높은 성능을 보장하는 이유 (I/O Multiplexing)
### 1. 싱글 스레드 이벤트 루프 → 락(lock) 비용, 문맥 전환 없음 
- 요약:
    - Redis는 한 번에 하나의 명령만 처리하기 때문에 락(lock) 경합이 전혀 없고, 멀티스레드에서 발생하는 문맥 전환 비용도 발생하지 않습니다. 이 덕분에 CPU 캐시 효율이 높아져 요청을 매우 빠르게 처리할 수 있습니다.
    ```
    멀티 스레드: 
    스레드1 실행 → 캐시 적재 → 전환 → 캐시 Flush → 스레드2 적재 (반복)

    싱글 스레드:
    스레드1 계속 실행 → 캐시 유지 → 반복 접근 속도 빠름
    ```
- 싱글 스레드란? 
    - 한번에 하나의 스레드(=작업 흐름)만 실행하는 구조 
    - Redis는 명령을 처리하는 메인 스레드가 하나뿐이다 -> 동시에 여러 명령을 처리하는 것처럼 보이지만, 사실은 한 줄로 처리됨 
    - 비유: 
        - 싱글 스레드 = 계산대 1개 있는 편의점
	    - 멀티 스레드 = 계산대 여러 개 있는 대형 마트
- 이벤트 루프란? 
    - 싱글 스레드가 여러 클라이언트 요청을 빠르게 처리할 수 있도록 I/O 이벤트를 기다렸다가 처리하는 반복 구조를 말한다 
    - Redis의 이벤트 루프는 아래와 같이 동작한다: 
        1. I/O Multiplexing (epoll, kqueue 같은 OS 기능)으로 여러 소켓 상태 감시
        2. 읽을 게 있는 소켓이 생기면 이벤트 루프가 처리
        3. 결과를 쓰고 다시 감시 상태로 돌아감
    - 비유:
	    - 계산대 직원(싱글 스레드)이 한 명이지만, 여러 손님이 줄 서 있는 게 아니라 손님이 물건 꺼냈을 때만 알림을 받고 처리하는 구조        
- 락 경합(Lock contention)이 없다는 의미? 
    - 멀티 스레드 환경에서는 공유 자원(예: 메모리, 데이터 구조)을 여러 스레드가 동시에 접근함
    ```
    → 그래서 뮤텍스/락으로 동기화해야 함
    → 동시에 접근하려고 하면 락 경합 발생 (대기 시간 ↑, 성능 ↓)
        •	싱글 스레드는 어차피 한 번에 하나의 명령만 실행
    → 락이 필요 없음 → 락 경합 0%
    ```
    - 정리: 
        - 락 경합 없음 = 동시에 자원 접근할 경쟁이 없으니 대기 시간도 없음
- 문맥 전환(Context Switch) 비용? 
    - 멀티 스레드/멀티 프로세스에서는 CPU가 스레드를 번갈아 실행함
        ```
        → 실행 중이던 스레드 상태 저장 + 새 스레드 상태 불러오기 필요
        → 이게 문맥 전환(Context Switch)
        ```
    - 하지만 싱글 스레드에서는 스레드가 하나라서
        ```
        → 스위칭할 필요가 없음 → 문맥 전환 비용 0
        ```
- CPU 캐시 효율이 높아지는 이유
    - CPU는 자주 쓰는 데이터를 L1/L2 캐시에 저장해두고 빠르게 접근함
    - 멀티 스레드에서는 스레드 전환할 때 **캐시가 무효화(Flush)**됨 → 새 스레드 데이터 로딩 → 캐시 미스 ↑
    - 싱글 스레드는 한 스레드만 계속 돌아가므로 → 캐시가 유지되어 연속적 접근 효율 ↑


### 2. I/O Multiplexing(epoll/kqueue)
- 요약:
    - I/O Multiplexing 기법: 
        - Redis는 싱글 스레드지만 I/O Multiplexing으로 높은 성능을 냅니다.
        구체적으로, Redis는 내부적으로 epoll(리눅스)이나 kqueue(맥) 같은 OS 이벤트 감시 시스템을 사용합니다.
        OS 이벤트 감시 시스템을 사용해서 수천, 수만 개 클라이언트 연결/소켓의 연결을 동시에 유지해도, 읽기·쓰기 준비가 된 소켓만 이벤트 큐에 등록해 처리하므로 불필요한 CPU 낭비가 없습니다. 네트워크 I/O는 디스크 I/O보다 훨씬 빠르기 때문에 싱글 스레드임에도 비효율 없이 네트워크 I/O를 처리할 수 있습니다.
    - e.g. 
    ```
    [클라이언트1]   [클라이언트2]   [클라이언트3]
        ↓               ↓               ↓
    TCP 소켓        TCP 소켓        TCP 소켓
        ↓               ↓               ↓
    ───────────── OS 커널 (epoll) ─────────────
        ↳ 읽기/쓰기 준비된 소켓만 알려줌
                        ↓
            [이벤트 큐 + 이벤트 루프]
            1. 소켓 이벤트 꺼내 처리
            2. 응답 보내기
    ```
- I/O 작업이란?
    - Input/Output의 줄임말, 데이터를 주고받는 행위 전반 
    - 종류: 
        - Disk I/O: 파일 읽기/쓰기 (DB에서 디스크 접근)
        - Network I/O: TCP 소켓을 통해 데이터 송수신
        - Memory I/O: CPU ↔ RAM ↔ Cache 간 데이터 이동
    - Redis는 디스크보다는 네트워크 I/O가 중요. 클라이언트와 데이터를 주고받아야 하니까.
- 소켓? 
    - 네트워크에서 데이터를 주고받기 위한 논리적 통로 (IP + Port를 기반으로 TCP/UDP 연결을 담당)
    - Redis 내부에서 클라이언트 요청을 처리할 때 항상 소켓 단위로 I/O를 수행한다 
- 이벤트 감시 시스템(epoll / kqueue)
    - 이벤트 감시 시스템 = OS 커널이 제공하는 네트워크 이벤트 감시 기능
    - 역할:
        - 수많은 소켓의 상태(읽기/쓰기 가능 여부)를 커널이 대신 감시
        - 준비된 소켓만 알려줌 → CPU 낭비 방지
    - OS별 구현: 
        - Linux → epoll
	    - macOS/BSD → kqueue
    - 즉, Redis는 스스로 1만 개 소켓을 매번 확인하지 않고 커널에게 "이 소켓들 상태 바뀌면 알려줘"라고 맡기는 것



### 3. 모든 데이터를 메모리에서 처리 → 디스크 I/O 최소화
- 요약: 
    - 마지막으로 내부적으로 최적화된 자료구조 덕분에 Redis는 대부분의 연산을 메모리 안에서 O(1) ~ O(log n)정도로 작업을 처리할 수 있게 해놨습니다. 이렇게 Redis의 내부적으로 최적화된 자료 구조 덕분에 디스크를 자주 안쓰고, CPU랑 메모리 만으로도 대부분의 동작이 가능하기 때문에 I/O 작업에서 빠른 속도를 보여줍니다.


---
<details>
<summary>cf. reference</summary>

- https://velog.io/@ohjinseo/Redis%EA%B0%80-%EC%8B%B1%EA%B8%80-%EC%8A%A4%EB%A0%88%EB%93%9C-%EB%AA%A8%EB%8D%B8%EC%9E%84%EC%97%90%EB%8F%84-%EB%86%92%EC%9D%80-%EC%84%B1%EB%8A%A5%EC%9D%84-%EB%B3%B4%EC%9E%A5%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0-IO-Multiplexing

</details>
