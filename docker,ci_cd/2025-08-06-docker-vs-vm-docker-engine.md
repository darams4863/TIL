---
title: "Docker란? Docker vs VM"
date: 2025-08-06
categories:
  - docker
tags:
  - docker
  - vm
  - docker image
  - docker engine
  - container
  - interview
---

# Docker란? Docker vs VM & 이미지 vs 컨테이너

## 1. Docker란 무엇인가?

Docker는 애플리케이션과 실행 환경을 컨테이너(Container) 형태로 패키징하여 어디서든 동일한 환경에서 실행할 수 있도록 해주는 가상화 플랫폼입니다.

### 1-1. 핵심 장점

#### 1) 환경 일관성 보장 (로컬, 스테이징, 운영 환경 동일화)
- 로컬에서는 잘 돌어가던 코드가 서버에서 오류가 나는 경우가 더러 있는데, 주원인은 환경(OS 버전, 설치된 라이브러리, 설정 등)이 조금씩 달라서 생기는 것이다. 
- 이때 Docker는 Dockerfile에 모든 실행 환경(Linux 버전, Python 3.11, 패키지들 등)을 명시 → 도커 이미지를 만들면 어디서든 같은 환경으로 컨테이너를 실행할 수 있게 된다.
- 운영 서버, 개발 서버, 로컬 → 모두 동일한 컨테이너 환경에서 실행된다 

#### 2) 배포 효율화 (컨테이너 단위로 이동/재배포/롤백이 용이)
- **기존 배포**: 
  - 서버 접속 → 소스 코드 복사 → Python 설치 → 패키지 설치 → 설정 → 실행 
  - 시간이 오래 걸리고, 서버마다 설정이 달라 에러 발생 가능성이 증가한다 
- **Docker**: 도커 이미지를 빌드하면, 앱 실행에 필요한 모든 게 다 들어있다 → `docker run myapp:1.0`만 하면 실행 완료 
- 특히 CI/CD 자동화와 조합이 좋다: Github Actions로 이미지 빌드 → 서버에 배포 → 바로 컨테이너 실행 가능 

#### 3) 경량화 (VM 대비 리소스를 적게 사용, 시작 속도 빠름)
- 기존 VM으로 가상화를 할 때는 OS를 커널까지 통째로 포함해야 해서 하나의 물리 서버에 올린 OS만큼의 커널이 포함되어있고, 부팅할 때 오래 걸리고 메모리도 많이 잡아먹었다면, 
- 도커는 커널은 호스트 OS와 공유해서 필요한 라이브러리와 앱 실행 파일만 포함한다 → 컨테이너에 올라가는 시간이 빠르고, 메모리도 적게 사용한다 


---

## 2. VM vs 컨테이너

### 2-1. 핵심 차이점 요약 테이블

| 항목 | VM (Virtual Machine) | Docker (Container) |
|------|---------------------|-------------------|
| **구조** | Hypervisor + Guest OS + App | Host OS + Docker Engine + App(Container) |
| **부팅 속도** | 수십 초~수 분 | 수 초 이내 |
| **리소스 사용** | 무겁고 고정 | 경량, 동적 사용 가능 |
| **환경 격리** | OS 단위 완전 격리 | 프로세스 단위 격리 (Namespace) |
| **이식성** | 제한적 | 이미지 기반으로 높은 이식성 |

**가장 큰 차이점:**
- **VM**: Hypervisor를 통해 하드웨어를 가상화하여 각각의 독립적인 OS 환경 제공
- **컨테이너**: Host OS 커널을 공유하여 프로세스 수준의 격리 제공

### 2-2. 커널이란?

- 운영체제(OS)의 핵심 부분으로 CPU, 메모리, 디스크, 네트워크 같은 하드웨어 자원 관리를 담당한다.
- 우리가 실행하는 모든 프로그램은 결국 커널을 통해 하드웨어에 접근합니다. 
- VM과 컨테이너의 차이를 커널 관점에서 보면:

#### 1) VM
- 하이퍼바이저가 하드웨어를 가상화해서 각 VM마다 자체 커널을 가진다. 
- 예: 물리 서버 1대에서 3개의 VM → 커널도 3개가 실행됨 → 무겁고 부팅이 느린 이유

#### 2) 컨테이너 
- 호스트 OS 커널을 그대로 공유합니다 
- 컨테이너는 독립적인 앱처럼 보이지만 사실 호스트의 커널을 같이 사용한다 
- 그래서 부팅할 때 OS를 새로 켤 필요없이, 프로세스만 실행하면 된다 

**정리**: 컨테이너는 자신만의 온전한 OS를 가지지 않고, 호스트의 커널을 그대로 빌려 쓰면서 프로세스 단위로 격리된 환경을 제공한다. 

### 2-3. 컨테이너가 OS에 상관없이 실행 가능한 이유?

**Host OS 커널 공유 + Namespace + cgroups** 덕분

#### 2-3-1. Namespace와 cgroups란?

**Namespace (네임스페이스):**
- 여러 컨테이너가 동시에 떠 있어도, 마치 독립적인 OS처럼 보이게 해주는 기술이다 
- 리눅스 커널 기능 중 하나이고, 하나의 호스트 OS 안에서 각 컨테이너가 독립적인 환경처럼 보이도록 만들었다 
- **주요 Namespace 종류:**
  - **PID Namespace**: 프로세스 ID 격리 (각 컨테이너는 독립적인 PID 공간)
  - **Network Namespace**: 네트워크 인터페이스, 라우팅 테이블 격리
  - **Mount Namespace**: 파일시스템 마운트 포인트 격리
  - **UTS Namespace**: 호스트명과 도메인명 격리
  - **IPC Namespace**: 프로세스 간 통신 격리
  - **User Namespace**: 사용자 ID와 그룹 ID 격리

**cgroups (Control Groups):**
- cgroups는 CPU, 메모리, 디스크 IO, 네트워크 등 시스템 자원을 각 컨테이너마다 제한/통제하는 기술입니다 
- 리눅스 커널 기능 중 하나이고, 컨테이너 하나가 자원을 무한정 쓰지 못하게 막아준다. 
- **주요 제어 항목:**
  - **CPU**: CPU 사용량 제한 및 할당
  - **Memory**: 메모리 사용량 제한
  - **I/O**: 디스크 I/O 대역폭 제한
  - **Network**: 네트워크 대역폭 제한

#### 2-3-2. 정리

```text 
Namespace → 격리된 독립 공간을 만들고 
cgroups → 각 컨테이너마다의 리소스를 제한함으로써 컨테이너가 마치 다른 OS에서 돌아가는 것처럼 보이게 한다. 

[정리]
- 컨테이너가 독립적으로 동작할 수 있는 원리? 
  - 컨테이너는 실제로는 호스트 OS의 리눅스 커널을 공유하면서 실행됩니다. 
  따라서 새로운 운영체제를 부팅하거나 설치할 필요 없이,
  커널만 함께 쓰고 그 위에서 격리된 프로세스처럼 동작합니다.

  이때 리눅스 커널이 제공하는 Namespace를 활용해
  프로세스, 네트워크, 파일시스템, 사용자 권한 등을 격리하고,
  cgroups(Control Groups) 를 통해 각 컨테이너의 CPU, 메모리, 디스크 등의 자원 사용량을 제한합니다.

  이런 구조 덕분에:
    • 컨테이너는 마치 독립된 OS처럼 보이지만, 실제로는 호스트 커널을 함께 사용하는 가벼운 프로세스이고,
    • 동시에 여러 컨테이너가 떠 있어도 서로의 존재를 인식하지 못한 채,
    • 독립적이고 일관된 환경에서 실행될 수 있습니다.
```


### 2-4. Docker 보안 고려사항

Docker 컨테이너는 호스트 OS의 커널을 공유합니다.
이는 VM처럼 자체 OS를 부팅하지 않기 때문에 성능 면에서는 효율적이지만,
보안 측면에서는 몇 가지 주의할 점이 존재합니다.

#### 2-4-1. Host 커널 공유로 인한 보안 이슈 3가지 

1. **커널 취약점 전파**:
   - 모든 컨테이너는 호스트의 커널을 함께 사용합니다.
   - 따라서 커널에 보안 취약점이 존재할 경우, 하나의 컨테이너에서 발생한 공격이 커널을 통해 다른 컨테이너나 호스트 전체로 확장될 수 있습니다.

2. **권한 상승 (Privilege Escalation)**:
   - 컨테이너 내부의 프로세스가 루트 권한을 가진 경우, 적절한 제한이 없으면 호스트 시스템에 직접 접근하거나 영향을 미칠 수 있습니다.

3. **리소스 고갈 공격**:
   - 어떤 컨테이너가 무제한으로 CPU, 메모리, 디스크 등을 사용할 경우, 다른 컨테이너나 호스트 전체 서비스에 심각한 장애를 유발할 수 있습니다.

#### 2-4-2. 보안 이슈 대책 

| **항목** | **설명** |
|----------|----------|
| 최신 커널 유지 | 커널의 보안 취약점을 막기 위해 리눅스 커널을 주기적으로 업데이트하여 공유 커널의 보안성을 확보 |
| root 권한 제한 | 컨테이너는 --user 옵션으로 일반 사용자 권한으로 실행 |
| --privileged 플래그 사용 금지 | 거의 모든 권한을 허용하는 옵션은 보안상 매우 위험하므로 사용하지 않음 |
| cgroups 설정 | CPU, 메모리, I/O 사용량 제한 설정으로 리소스 고갈 방지 |
| 읽기 전용 파일시스템 | --read-only 옵션으로 컨테이너 내부 쓰기 방지 가능 | 

#### 2-4-3. 보안 설정 예시 코드

```bash 
# 일반 사용자 권한으로 실행
docker run --user 1000:1000 -it ubuntu bash

# 리소스 제한 (512MB RAM, CPU 1개)
docker run --memory=512m --cpus=1.0 -it ubuntu bash

# 읽기 전용 파일시스템
docker run --read-only -it ubuntu bash

# 보안 옵션 설정 (권한 상승 금지)
docker run --security-opt=no-new-privileges -it ubuntu bash
```


## 3. Docker의 주요 구성 요소 > Docker Engine

위에서는 도커와 VM의 차이점과, 도커의 동작 원리, 그리고 보안상의 이슈와 해결책에 대해 알아봤다. 이제 도커를 구성하는 요소들 중 도커의 심장이라 할 수 있는 `Docker Engine`에 대해 알아보자.

### 3-1. Docker 구성 요소 정리

| 구성 요소 | 설명 |
|-----------|------|
| 1. Docker Engine | 컨테이너를 만들고 실행하는 핵심 컴포넌트 (daemon + CLI + API) |
| 2. Docker CLI | docker 명령어로 컨테이너와 이미지를 제어하는 명령줄 도구 |
| 3. Docker Image | 컨테이너를 만들기 위한 실행 환경과 코드가 담긴 템플릿 파일 |
| 4. Docker Container | 이미지를 실행한 인스턴스. 실제로 돌아가는 애플리케이션 |
| 5. Dockerfile | 이미지를 만들기 위한 설정 파일 (코드 기반 이미지 정의) |
| 6. Docker Compose | 여러 개의 컨테이너를 한 번에 정의하고 실행하는 도구 (docker-compose.yml) |
| 7. Docker Hub | 공식 이미지 저장소. 이미지 공유/배포 가능 (Public Registry) |
| 8. Docker Volume | 컨테이너 외부에 데이터를 저장할 수 있도록 해주는 디스크 공간 |
| 9. Docker Network | 컨테이너 간 통신을 위한 가상 네트워크 관리 기능 |
| 10. Docker Registry | Docker Hub처럼 이미지 저장/배포하는 공간 (Private 가능) |

Docker는 컨테이너를 실행하기 위한 핵심 컴포넌트인 Docker Engine을 중심으로, 이미지를 정의하는 Dockerfile, 여러 컨테이너를 관리하는 Compose, 이미지를 공유하는 Docker Hub, 그리고 데이터를 저장하는 Volume 등 여러 구성 요소들이 유기적으로 연결되어 있는 플랫폼입니다.

### 3-2. Docker Engine 구성도

```
[사용자]
  ↓ (명령어 입력: docker run)
[Docker CLI]
  ↓
[Docker Engine]
  ├── Docker Daemon (dockerd)
  ├── containerd
  ├── runc
  ↓
[Docker Image] → [Docker Container]
```

### 3-3. Docker Engine 상세

- `docker run`, `docker build`, `docker ps` 등을 CLI로 치면, 실제로 컨테이너를 만들고 실행하는 건 이 도커 엔진(Docker Daemon)이 하는 일이다
- 이미지 관리, 컨테이너 생성, 네트워크 설정, 볼륨 마운트 등 모든 핵심 기능이 Docker Engine 내부에서 작동된다 
- (cf. 다른 요소는 추후 다룰 예정)

#### 3-3-1. Docker Engine을 구성하는 컴포넌트

- **Docker Daemon**:
  - 백그라운드에서 동작하며 컨테이너 생성/관리
- **Docker CLI** 
  - 사용자 명령어 입력 도구 (예: docker run, docker ps)
- **REST API** 
  - CLI나 외부 툴과 통신할 수 있는 인터페이스 

**요약**: 사용자가 CLI나 API로 요청 → Docker Daemon이 이를 수신 → 컨테이너 실행/중단 등 관리 수행


---

---
<details>
<summary>cf. reference</summary>

- https://wonos.tistory.com/entry/%EB%8F%84%EC%BB%A4-%EB%A9%B4%EC%A0%91-%EC%A7%88%EB%AC%B8-20%EC%84%A0-%EC%A0%95%EB%A6%AC-%EC%8B%A4%EB%AC%B4-%EA%B0%9C%EB%B0%9C%EC%9E%90%EB%9D%BC%EB%A9%B4-%EA%BC%AD-%EC%95%8C%EC%95%84%EC%95%BC-%ED%95%A0-%ED%95%B5%EC%8B%AC-%EA%B0%9C%EB%85%90
- https://github.com/CHEE-UP/TECH-INTERVIEW
- https://yubeen-ha.tistory.com/176
- 
</details> 