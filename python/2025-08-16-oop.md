---
title: "파이썬의 OOP"
date: 2025-08-16
categories:
  - python
tags:
  - python
  - oop
  - class
  - inheritance
  - polymorphism
  - interview
---

# 파이썬의 OOP
OOP 원칙은 코드의 재사용성, 유지보수성, 협업 효율성을 높이기 위해 사용된다. 특히 확장과 수정이 쉬운 구조를 만들기 위해 꼭 필요하다.

---

## 0. OOP 4대 원칙 
### 캡슐화(Encapsulation)
- 내부 구현을 감추고, 인터페이스만 공개해서 안전하게 데이터를 보호한다
- 파이썬 예시: __속성, @property, @setter 데코레이터
- 사용 이유: 
    - 외부에서 객체의 상태를 무분별하게 변경하는 것을 방지 
    - 내부 구현을 바꿔도 외부 코드에 영향 없도록 함 
- 실무 예시: 
    - 비밀번호, 계좌 잔액 등 민감 정보를 직접 수정 못하게 막고, 검증 로직을 갖춘 메서드로만 접근하게 제한


### 상속(Inheritance)
- 부모 클래스의 속성과 메서드를 자식 클래스가 물려받아 재사용 
- 파이썬 예시: class 자식(부모)
- 사용 이유: 
    -중복 코드를 제거
    - 공통 로직을 상위 클래스에 모아 코드 관리 효율화
- 실무 예시: 
    - 기본 로직을 물려받아 기능 확장 가능
    - 코드 관리와 유지보수 효율화
        - 예: BaseAPIView를 상속해서 API 여러 개 만들기, BaseHandler를 상속하여 플랫폼별 프롬프트 처리 전략을 분리 구현

### 다형성(Polymorphism)
- 동일한 메서드 이름이 클래스에 따라 다르게 동작하는 것
- 파이썬 예시: 오버라이딩, duck typing
- 사용 이유: 
    - 인터페이스는 유지하면서 객체마다 다른 방식으로 동작 가능 
    - 확장성과 유연성을 높임
- 실무 예시: 
    - 코드를 일반화해서 유연하게 만들 수 있음
    - 객체가 달라도 함수 로직은 같게 유지
        - 예: save() 함수 하나로 여러 타입 객체 저장, send() 메서드를 각기 다른 알림 채널(SMS, Email, Slack)에 맞게 구현


### 추상화(Abstraction)
- 핵심 로직만 드러내고 세부 구현은 감추는 설계 방식 
- 파이썬 예시: abc.ABC, @abstractmethod를 사용한 추상 클래스 정의
- 사용 이유: 
    - 구조를 명확히 규정하여 개발자 간 현업이나 유지보수 시 일관성 유지 
    - 구현은 다 달라도 '무조건 있어야 할 메서드'를 강제할 수 있음
    - 복잡한 구조를 단순하게 표현하고, 강제적인 구조 제공 
- 실무 예시: 
    - Notificator 추상 클래스를 만들어, send() 메서드를 필수 구현하도록 강제
    - 덕분에 Email, Slack, SMS 클래스는 공통된 인터페이스로 다룰 수 있음

### cf. 오버라이딩 vs 덕 타이핑 
- 오버라이딩 예시: 

```python
class BaseHandler:
    def generate(self, input):
        raise NotImplementedError

class GptHandler(BaseHandler):
    def generate(self, input):
        return "GPT 모델 결과"

class ClaudeHandler(BaseHandler):
    def generate(self, input):
        return "Claude 모델 결과"

# generate()라는 동일한 이름의 메서드를 다르게 재정의 
# -> 오버라이딩 + 다형성의 예시. 
# -> 같은 인터페이스지만 각기 다른 방식으로 동작.
```

- 덕 타이핑 예시: 

```python
# 추상 클래스 상속 없이도 이렇게 사용 가능
class GptHandler:
    def generate(self, input):
        return "GPT 결과"

class ClaudeHandler:
    def generate(self, input):
        return "Claude 결과"

def process(handler, input):
    return handler.generate(input)

# 여기서 GptHandler든 ClaudeHandler든 generate()만 있으면 처리 가능
print(process(GptHandler(), "hi"))
print(process(ClaudeHandler(), "hi"))

# handler가 generate 메서드를 갖고있기만 하면 타입은 신경 안쓰고 작동한다는 의미에서 
# -> 타입 검사보다 행동을 본다 
# -> "오리처럼 걷고 꽥꽥거린다면 오리로 취급하자"
# -> 타입 신경 X, 그냥 같은 이름의 메서드 갖고있으면 작동함!
```

- 즉, 추상클래스를 상속받아 메서드를 구현하는 구조는 `오버라이딩 + 다형성`, 인터페이스 구현 여부를 체크하지 않고도 동일한 메서드 이름만 있으면 호출한느 구조는 `덕 타이핑`. 실무에서는 둘 다 자주 쓰는데...
    - 안정성, 명확한 명세를 원하면 -> 추상 클래스 상속 + 오버라이딩
    - 유연성, 확장성을 원하면 -> 덕 타이핑 기반으로 동작하게 한다 


## 1. 클래스와 객체의 기본 개념

### 클래스 정의와 인스턴스 생성

```python
class User:
    user_count = 0  # 클래스 변수

    def __init__(self, name):
        self.name = name  # 인스턴스 변수
        User.user_count += 1

    def greet(self):
        """인스턴스 메서드: 인스턴스 상태에 접근"""
        return f"안녕하세요, 저는 {self.name}입니다."

    @classmethod
    def get_user_count(cls):
        """클래스 메서드: 클래스 상태(user_count)를 조회"""
        return f"총 사용자 수: {cls.user_count}"

    @staticmethod
    def is_valid_name(name):
        """정적 메서드: 클래스와 무관한 유틸성 검증"""
        return isinstance(name, str) and len(name) > 1

# 첫번쨰 유저 객체 
user1 = User("다람이")
user1.greet()  # "안녕하세요, 저는 다람이입니다."

# 두번쨰 유저 객체 
user2 = User("다람쥐")
user2.greet()  # "안녕하세요, 저는 다람쥐입니다."

User.get_user_count()  # 총 사용자 수: 2
user1.get_user_count()  # 이렇게도 호출 가능 (내부적으로 User.get_user_count())

# elf도 cls도 안 쓰고, 단순히 인자만 판단함. 이건 유저 클래스의 부가 기능(유틸성 함수)일 뿐이니까. 도우미 함수일뿐
User.is_valid_name("다람이")  # True
User.is_valid_name("")       # False
```

### 클래스 변수 vs 인스턴스 변수

```python
class Configuration:
    """설정 클래스 - 클래스 변수 활용"""
    
    # 클래스 변수 (모든 인스턴스가 공유)
    DATABASE_URL = "postgresql://localhost:5432/mydb"
    API_KEY = "secret_key_123"
    DEBUG_MODE = True
    
    def __init__(self, environment: str = "development"):
        self.environment = environment  # 인스턴스 변수
    
    def get_database_url(self) -> str:
        """데이터베이스 URL 반환"""
        if self.environment == "test":
            return "postgresql://localhost:5432/testdb"
        return self.DATABASE_URL
    
    @classmethod
    def set_debug_mode(cls, debug: bool) -> None:
        """디버그 모드 설정 (클래스 레벨)"""
        cls.DEBUG_MODE = debug
    
    @classmethod
    def get_config(cls) -> dict:
        """전체 설정 반환"""
        return {
            'database_url': cls.DATABASE_URL,
            'api_key': cls.API_KEY,
            'debug_mode': cls.DEBUG_MODE
        }

# 사용 예시
config1 = Configuration("production")
config2 = Configuration("test")

print(f"Config1 DB: {config1.get_database_url()}")
print(f"Config2 DB: {config2.get_database_url()}")

# 클래스 변수 변경 (모든 인스턴스에 영향)
Configuration.set_debug_mode(False)
print(f"Debug mode: {Configuration.DEBUG_MODE}")  # False
print(f"Config1 debug: {config1.DEBUG_MODE}")    # False
print(f"Config2 debug: {config2.DEBUG_MODE}")    # False
```

---

## 2. 상속과 다형성

### 기본 상속
- 상속의 장점:
    - 코드 재사용
        - 부모 클래스의 기능을 자식 클래스에서 그대로 사용 가능 → 중복 제거
    - 공통 로직 분리
        - 공통 기능을 상위 클래스에 모아 관리하면 코드 일관성 유지 가능
    - 다형성 활용
        - 동일한 인터페이스로 다양한 객체를 처리할 수 있음 (오버라이딩)
    - 의미 있는 계층 구조 표현  
        - 도메인 구조나 계층 구조를 코드로 표현할 수 있음
- 상속의 단점:
    - 높은 결합도
        - 부모 클래스 변경 시 자식 클래스에 의도치 않은 영향 발생 가능
    - 상속 깊어질수록 복잡성 증가 
        - MRO, 오버라이딩, super() 호출 흐름 등 디버깅 어려움
    - 구조 변경 어려움
        0 잘못된 상속 구조는 추후 리팩토링이 매우 어려움 (e.g. 부모 클래스 기능 분리 시 전체 영향)
    - 불필요한 상속 위험 
        - “is-a” 관계가 아닌데 상속을 쓰면 코드 설계가 어색해지고 오용될 수 있음
- 실무 팁: 상속보다 컴포지션이 권장됨 
- 상속 예: 

```python
class Animal:
    """동물 기본 클래스"""
    
    def __init__(self, name: str, species: str):
        self.name = name
        self.species = species
    
    def speak(self) -> str:
        """소리 내기 (추상 메서드)"""
        return "동물이 소리를 냅니다"
    
    def move(self) -> str:
        """움직이기"""
        return f"{self.name}이(가) 움직입니다"
    
    def get_info(self) -> str:
        """동물 정보"""
        return f"{self.name} ({self.species})"

class Dog(Animal):
    """강아지 클래스"""
    
    def __init__(self, name: str, breed: str):
        super().__init__(name, "강아지")
        self.breed = breed
    
    def speak(self) -> str:
        """강아지 소리"""
        return f"{self.name}: 멍멍!"
    
    def fetch(self) -> str:
        """공 가져오기"""
        return f"{self.name}이(가) 공을 가져옵니다"
    
    def get_info(self) -> str:
        """강아지 정보 (부모 메서드 오버라이드)"""
        base_info = super().get_info()
        return f"{base_info} - 품종: {self.breed}"

class Cat(Animal):
    """고양이 클래스"""
    
    def __init__(self, name: str, color: str):
        super().__init__(name, "고양이")
        self.color = color
    
    def speak(self) -> str:
        """고양이 소리"""
        return f"{self.name}: 야옹~"
    
    def climb(self) -> str:
        """나무 오르기"""
        return f"{self.name}이(가) 나무를 올라갑니다"

# 다형성 활용
animals = [
    Dog("멍멍이", "골든 리트리버"),
    Cat("야옹이", "주황색"),
    Dog("바둑이", "진돗개")
]

# 모든 동물이 speak() 메서드를 가지고 있지만 각각 다르게 동작
for animal in animals:
    print(f"{animal.get_info()}")
    print(f"  소리: {animal.speak()}")
    print(f"  움직임: {animal.move()}")
    
    # 타입별 특별한 동작
    if isinstance(animal, Dog):
        print(f"  특기: {animal.fetch()}")
    elif isinstance(animal, Cat):
        print(f"  특기: {animal.climb()}")
    print()
```

### 다중 상속과 MRO (Method Resolution Order)
- 다중 상속: 하나의 클래스가 여러 개의 부모 클래스로부터 속성과 메서드를 상속받는 것 
- 파이썬에서 다중 상속시 어떤 순서로 메서드를 탐색할지 정하는 규칙 

```python
class A:
    def say(self):
        print("A")

class B:
    def say(self):
        print("B")

class C(A, B):  # 다중 상속
    pass

c = C()
c.say()  # A 출력됨. 왜? MRO 

# MRO 확인 방법 
print(C.mro())
# 또는
help(C)
# 결과 예시
# [<class '__main__.C'>, <class '__main__.A'>, <class '__main__.B'>, <class 'object'>]

# 예시 2. 
class A:
    def say(self):
        print("A")

class B(A):
    def say(self):
        print("B")

class C(A):
    def say(self):
        print("C")

class D(B, C):
    pass

d = D()
d.say()  # ??
print(D.mro())
# B
# [<class '__main__.D'>, <class '__main__.B'>, <class '__main__.C'>, <class '__main__.A'>, <class 'object'>]

""" 
D는 B, C를 상속받았지만 B가 A를 먼저 상속받고, C도 A를 상속한 상황 
따라서 B -> C -> A 순서로 메서드가 탐색됨 
즉, MRO 순서대로 메서드를 찾다가 처음 발견되면 그걸 실행함.
=> 다중 상속시 이름 충돌이 있으면 MRO에 따라 우선순위가 결점됨에 유의!
"""
```

---

## 3. 추상 클래스와 인터페이스
- 파이썬에서는 추상클래스가 인터페이스 역할까지 포함한다 (unlike e.g. C#)
### 추상 클래스
- 추상클래스를 사용하는 이유는 2가지:
    - 공통된 인터페이스를 강제하기 위해 
    - 다형성 + 코드 일관성 유지 
    - 예:

    ```python 
    from abc import ABC, abstractmethod

    class Animal(ABC):
        @abstractmethod
        def speak(self):
            # 공통된 인터페이스를 강제하기 위해 -> 구현을 깜박하는 실수 방지. 협업할 때도 팀원간 암묵적 규약 없이 코드로 명시 가능.
            pass

    class Dog(Animal):
        def speak(self):
            print("멍멍")

    class Cat(Animal):
        def speak(self):
            print("야옹")

    # 다형성 + 코드 일관성 유지 
    def call_speak(animal: Animal):
        animal.speak()

    call_speak(Dog())
    call_speak(Cat())
    ```

---

## 4. 매직 메서드와 연산자 오버로딩
- 예: 

```python
class Product:
    """상품 클래스 - 다양한 매직 메서드 포함"""
    
    def __init__(self, name: str, price: int):
        self.name = name
        self.price = price

    def __str__(self):
        """사용자 친화적 문자열"""
        return f"{self.name} 상품 - {self.price}원"

    def __repr__(self):
        """디버깅/로깅용 표현"""
        # 원래 객체가 상속받은 __repr__을 사용하면 객체 주소를 반환해서 너무 추상적 -> 커스텀 해서 개발자가 디버깅 하기 용이하게 사용 
        return f"Product(name='{self.name}', price={self.price})"

    def __eq__(self, other):
        """같은 상품인지 비교"""
        return isinstance(other, Product) and self.name == other.name and self.price == other.price

    def __hash__(self):
        """set이나 dict key로 사용 가능하게 함"""
        return hash((self.name, self.price))

    def __add__(self, other):
        """상품 가격 더하기 (묶음 상품 계산 등)"""
        if isinstance(other, Product):
            return self.price + other.price
        return NotImplemented

    def __len__(self):
        """상품명 길이 반환 (len(product))"""
        return len(self.name)

    def __call__(self):
        """상품을 호출하면 소개 메시지 출력"""
        return f"{self.name}는 {self.price}원입니다."

# 사용 예시
p1 = Product("라면", 800)
p2 = Product("삼각김밥", 1200)
p3 = Product("라면", 800)

print(p1)               # ✅ __str__ → 라면 상품 - 800원
print(repr(p1))         # ✅ __repr__ → Product(name='라면', price=800)
print(p1 == p3)         # ✅ __eq__ → True
print(p1 + p2)          # ✅ __add__ → 2000
print(len(p1))          # ✅ __len__ → 2 (라면)
print(p1())             # ✅ __call__ → 라면는 800원입니다.

# ✅ __hash__ 덕분에 set에 넣을 수 있음
products = {p1, p2, p3}
print(products)         # {Product(name='삼각김밥', price=1200), Product(name='라면', price=800)} ← 중복 제거됨

# cf. 유의!
repr(p1)           # 실제로는 p1.__repr__() 호출
str(p1)            # 실제로는 p1.__str__() 호출
len(p1)            # 실제로는 p1.__len__() 호출
```

---

## 5. 프로퍼티와 디스크립터
- @property는 메서드를 마치 속성처럼 사용할 수 있게 해주는 파이썬 내장 데코레이터
    - 왜? @property는 함수지만 속성처럼 사용하고 싶기 떄문이다. 이를 가능하게 해주는 문법이 `@property` 이다 
### 프로퍼티 사용 이유 
- 상황: 함수처럼 쓰기 vs 속성처럼 보이게 만들기 

```python
# 함수처럼 쓰기
class Person:
    def __init__(self, height, weight):
        self.height = height  # meter
        self.weight = weight  # kg

    def get_bmi(self):
        return self.weight / (self.height ** 2)

p = Person(1.75, 70)
print(p.get_bmi())  # 호출 시 () 꼭 붙여야 함
# 문제: 잘 동작하기는 하지만 이건 "동작" 처럼 보이고, 사실상 bmi는 속성이다. (키, 몸무게처럼 객체의 상태에 따라 변하지 않는 값)

# vs

# 해결: @property로 속성처럼 보이게 하기 
class Person:
    def __init__(self, height, weight):
        self.height = height
        self.weight = weight

    @property
    def bmi(self):
        return self.weight / (self.height ** 2)

p = Person(1.75, 70)
print(p.bmi)  # 함수처럼 호출하지 않고, 속성처럼 접근
```

### 디스크립터
- 디스크립터는 객체의 속성 접근을 제어할 수 있는 클래스이다. 
- `__get__, __set__, __delete__`와 같은 매직 메서드를 구현하면 해당 속성을 읽을 때 / 쓸 때 / 삭제할 때 동작을 커스터마이징 할 수 있다.
- 언제 사용? 
    - 여러 클래스에서 공통된 속성 로직을 재사용하고 싶을 때. @property는 한 클래스에 종속되지만, 디스크립터는 독립 클래스라 재사용이 가능하기 때문이다. 
- 일반적인 매직 메서드와의 차이점? 
    - 매직 메서드와 디스크립터 모두 `__이름__` 형태의 특수한 메서드들이고 파이썬 내부 동작으로 커스터마이징 할 수 있게 한다는 공통점이 있지만, 매직 메서드는 객체 자체의 동작을 바꾸는 "행동 조작자"의 역할을 한다면(오버라이드), 디스크립터는 객체 안의 속성 접근을 가로채서 동작을 바꾸는 "속성 관리자"의 역할을 한다.
     
```python
class PositiveNumber:
    def __init__(self, name):
        self.name = name

    def __get__(self, instance, owner):
        return instance.__dict__[self.name]

    def __set__(self, instance, value):
        if value <= 0:
            raise ValueError(f"{self.name}는 0보다 커야 합니다.")
        instance.__dict__[self.name] = value

# 사용하는 클래스
class Product:
    price = PositiveNumber("price")
    stock = PositiveNumber("stock")

    def __init__(self, price, stock):
        self.price = price
        self.stock = stock

# 사용 예시
p = Product(1000, 3)
print(p.price)  # 1000

p.price = -500  # ❌ ValueError: price는 0보다 커야 합니다.
```

---

## 6. 믹스인과 컴포지션
- A, B 클래스가 있을 때 `상속`을 받아서 기능을 확장하느냐 (믹스인), 내부에 `포함`시켜서 기능을 위임하느냐(컴포지션)에 따라 각각 믹스인과 컴포지션으로 나뉜다 

### 믹스인 패턴
- 단독으로 쓰이지 않는 작은 기능 클래스를 다른 클래스에 상속으로 섞어 넣는 방식 
- 공통 기능을 여러 클래스에 얹고 싶을 떄 사용한다 (e.g. 여기에 로깅하나 추가하고 싶다. 믹스인 상속)

```python
class LoggingMixin:
    def log(self, message):
        print(f"[{self.__class__.__name__}] {message}")

class ValidationMixin:
    def validate_email(self, email):
        if '@' not in email:
            raise ValueError("잘못된 이메일 형식입니다")
        return True

class SerializationMixin:
    def to_dict(self):
        return {k: v for k, v in self.__dict__.items() if not k.startswith('_')}

    def to_json(self):
        import json
        return json.dumps(self.to_dict(), ensure_ascii=False)

class User(LoggingMixin, ValidationMixin, SerializationMixin):
    def __init__(self, name, email):
        self.validate_email(email)
        self.name = name
        self.email = email
        self.log(f"사용자 생성: {self.name}")

    def update_email(self, new_email):
        self.validate_email(new_email)
        self.email = new_email
        self.log(f"이메일이 {new_email}로 변경되었습니다")

# 사용 예시
u = User("철수", "chul@example.com")
u.update_email("new@example.com")
print(u.to_dict())
print(u.to_json())
```

### 컴포지션 패턴
- 다른 객체를 내부에 포함시켜서, 그 객체에 기능을 위임하는 방식 
- 동작이 복잡하고 상태가 있거나, 확장성을 고려해야 할 떄 권장되는 방식이다 (e.g. 서비스 안에 다른 서비스나 헬퍼를 넣고 싶다)

```python
class EmailService:
    """이메일 서비스"""

    def send_email(self, to: str, subject: str, body: str) -> bool:
        print(f"[EMAIL] 수신자: {to} | 제목: {subject} | 내용: {body}")
        return True

class SMSService:
    """SMS 서비스"""

    def send_sms(self, to: str, message: str) -> bool:
        print(f"[SMS] 수신자: {to} | 메시지: {message}")
        return True

class NotificationService:
    def __init__(self):
        self.email_service = EmailService()
        self.sms_service = SMSService()

    def send_notification_with_image(self, user_id: str, message: str, image_path: str):
        """알림 전송"""
        self.email_service.send_email(f"{user_id}@example.com", "📢 xxx 알림", full_message)
        self.sms_service.send_sms(f"+82-10-{user_id}", full_message)       
```


---

<details>
<summary>cf. reference</summary>

- 
</details> 