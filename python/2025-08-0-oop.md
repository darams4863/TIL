---
title: "파이썬의 OOP"
date: 2025-08-15
categories:
  - python
tags:
  - python, oop, class, inheritance, polymorphism, design-patterns, interview
---

# 파이썬의 OOP
- OOP 원칙은 코드의 재사용성, 유지보수성, 협업 효율성을 높이기 위해 사용된다. 특히 확장과 수정이 쉬운 구조를 만들기 위해 꼭 필요하다.

---

## 0. OOP 4대 원칙 
### 캡슐화(Encapsulation)
- 내부 구현을 감추고, 인터페이스만 공개해서 안전하게 데이터를 보호한다
- 파이썬 예시: __속성, @property, @setter 데코레이터
- 사용 이유: 
    - 외부에서 객체의 상태를 무분별하게 변경하는 것을 방지 
    - 내부 구현을 바꿔도 외부 코드에 영향 없도록 함 
- 실무 예시: 
    - 비밀번호, 계좌 잔액 등 민감 정보를 직접 수정 못하게 막고, 검증 로직을 갖춘 메서드로만 접근하게 제한


### 상속(Inheritance)
- 부모 클래스의 속성과 메서드를 자식 클래스가 물려받아 재사용 
- 파이썬 예시: class 자식(부모)
- 사용 이유: 
    -중복 코드를 제거
    - 공통 로직을 상위 클래스에 모아 코드 관리 효율화
- 실무 예시: 
    - 기본 로직을 물려받아 기능 확장 가능
    - 코드 관리와 유지보수 효율화
        - 예: BaseAPIView를 상속해서 API 여러 개 만들기, BaseHandler를 상속하여 플랫폼별 프롬프트 처리 전략을 분리 구현

### 다형성(Polymorphism)
- 동일한 메서드 이름이 클래스에 따라 다르게 동작하는 것
- 파이썬 예시: 오버라이딩, duck typing
- 사용 이유: 
    - 인터페이스는 유지하면서 객체마다 다른 방식으로 동작 가능 
    - 확장성과 유연성을 높임
- 실무 예시: 
    - 코드를 일반화해서 유연하게 만들 수 있음
    - 객체가 달라도 함수 로직은 같게 유지
        - 예: save() 함수 하나로 여러 타입 객체 저장, send() 메서드를 각기 다른 알림 채널(SMS, Email, Slack)에 맞게 구현


### 추상화(Abstraction)
- 핵심 로직만 드러내고 세부 구현은 감추는 설계 방식 
- 파이썬 예시: abc.ABC, @abstractmethod를 사용한 추상 클래스 정의
- 사용 이유: 
    - 구조를 명확히 규정하여 개발자 간 현업이나 유지보수 시 일관성 유지 
    - 구현은 다 달라도 '무조건 있어야 할 메서드'를 강제할 수 있음
    - 복잡한 구조를 단순하게 표현하고, 강제적인 구조 제공 
- 실무 예시: 
    - Notificator 추상 클래스를 만들어, send() 메서드를 필수 구현하도록 강제
    - 덕분에 Email, Slack, SMS 클래스는 공통된 인터페이스로 다룰 수 있음

#### 오버라이딩 vs 덕 타이핑 
- 오버라이딩 예시: 
```python
class BaseHandler:
    def generate(self, input):
        raise NotImplementedError

class GptHandler(BaseHandler):
    def generate(self, input):
        return "GPT 모델 결과"

class ClaudeHandler(BaseHandler):
    def generate(self, input):
        return "Claude 모델 결과"

# generate()라는 동일한 이름의 메서드를 다르게 재정의 
# -> 오버라이딩 + 다형성의 예시. 
# -> 같은 인터페이스지만 각기 다른 방식으로 동작.
```

- 덕 타이핑 예시: 
```python
# 추상 클래스 상속 없이도 이렇게 사용 가능
class GptHandler:
    def generate(self, input):
        return "GPT 결과"

class ClaudeHandler:
    def generate(self, input):
        return "Claude 결과"

def process(handler, input):
    return handler.generate(input)

# 여기서 GptHandler든 ClaudeHandler든 generate()만 있으면 처리 가능
print(process(GptHandler(), "hi"))
print(process(ClaudeHandler(), "hi"))

# handler가 generate 메서드를 갖고있기만 하면 타입은 신경 안쓰고 작동한다는 의미에서 
# -> 타입 검사보다 행동을 본다 
# -> "오리처럼 걷고 꽥꽥거린다면 오리로 취급하자"
# -> 타입 신경 X, 그냥 같은 이름의 메서드 갖고있으면 작동함!
```
- 즉, 추상클래스를 상속받아 메서드를 구현하는 구조는 `오버라이딩 + 다형성`, 인터페이스 구현 여부를 체크하지 않고도 동일한 메서드 이름만 있으면 호출한느 구조는 `덕 타이핑`. 실무에서는 둘 다 자주 쓰는데...
    - 안정성, 명확한 명세를 원하면 -> 추상 클래스 상속 + 오버라이딩
    - 유연성, 확장성을 원하면 -> 덕 타이핑 기반으로 동작하게 한다 


## 1. 클래스와 객체의 기본 개념

### 클래스 정의와 인스턴스 생성
```python
class User:
    user_count = 0  # 클래스 변수

    def __init__(self, name):
        self.name = name  # 인스턴스 변수
        User.user_count += 1

    def greet(self):
        """인스턴스 메서드: 인스턴스 상태에 접근"""
        return f"안녕하세요, 저는 {self.name}입니다."

    @classmethod
    def get_user_count(cls):
        """클래스 메서드: 클래스 상태(user_count)를 조회"""
        return f"총 사용자 수: {cls.user_count}"

    @staticmethod
    def is_valid_name(name):
        """정적 메서드: 클래스와 무관한 유틸성 검증"""
        return isinstance(name, str) and len(name) > 1

# 첫번쨰 유저 객체 
user1 = User("다람이")
user1.greet()  # "안녕하세요, 저는 다람이입니다."

# 두번쨰 유저 객체 
user2 = User("다람쥐")
user2.greet()  # "안녕하세요, 저는 다람쥐입니다."

User.get_user_count()  # 총 사용자 수: 2
user1.get_user_count()  # 이렇게도 호출 가능 (내부적으로 User.get_user_count())

# elf도 cls도 안 쓰고, 단순히 인자만 판단함. 이건 유저 클래스의 부가 기능(유틸성 함수)일 뿐이니까. 도우미 함수일뿐
User.is_valid_name("다람이")  # True
User.is_valid_name("")       # False
```

### 클래스 변수 vs 인스턴스 변수
```python
class Configuration:
    """설정 클래스 - 클래스 변수 활용"""
    
    # 클래스 변수 (모든 인스턴스가 공유)
    DATABASE_URL = "postgresql://localhost:5432/mydb"
    API_KEY = "secret_key_123"
    DEBUG_MODE = True
    
    def __init__(self, environment: str = "development"):
        self.environment = environment  # 인스턴스 변수
    
    def get_database_url(self) -> str:
        """데이터베이스 URL 반환"""
        if self.environment == "test":
            return "postgresql://localhost:5432/testdb"
        return self.DATABASE_URL
    
    @classmethod
    def set_debug_mode(cls, debug: bool) -> None:
        """디버그 모드 설정 (클래스 레벨)"""
        cls.DEBUG_MODE = debug
    
    @classmethod
    def get_config(cls) -> dict:
        """전체 설정 반환"""
        return {
            'database_url': cls.DATABASE_URL,
            'api_key': cls.API_KEY,
            'debug_mode': cls.DEBUG_MODE
        }

# 사용 예시
config1 = Configuration("production")
config2 = Configuration("test")

print(f"Config1 DB: {config1.get_database_url()}")
print(f"Config2 DB: {config2.get_database_url()}")

# 클래스 변수 변경 (모든 인스턴스에 영향)
Configuration.set_debug_mode(False)
print(f"Debug mode: {Configuration.DEBUG_MODE}")  # False
print(f"Config1 debug: {config1.DEBUG_MODE}")    # False
print(f"Config2 debug: {config2.DEBUG_MODE}")    # False
```

---

## 2. 상속과 다형성

### 기본 상속
```python
class Animal:
    """동물 기본 클래스"""
    
    def __init__(self, name: str, species: str):
        self.name = name
        self.species = species
    
    def speak(self) -> str:
        """소리 내기 (추상 메서드)"""
        return "동물이 소리를 냅니다"
    
    def move(self) -> str:
        """움직이기"""
        return f"{self.name}이(가) 움직입니다"
    
    def get_info(self) -> str:
        """동물 정보"""
        return f"{self.name} ({self.species})"

class Dog(Animal):
    """강아지 클래스"""
    
    def __init__(self, name: str, breed: str):
        super().__init__(name, "강아지")
        self.breed = breed
    
    def speak(self) -> str:
        """강아지 소리"""
        return f"{self.name}: 멍멍!"
    
    def fetch(self) -> str:
        """공 가져오기"""
        return f"{self.name}이(가) 공을 가져옵니다"
    
    def get_info(self) -> str:
        """강아지 정보 (부모 메서드 오버라이드)"""
        base_info = super().get_info()
        return f"{base_info} - 품종: {self.breed}"

class Cat(Animal):
    """고양이 클래스"""
    
    def __init__(self, name: str, color: str):
        super().__init__(name, "고양이")
        self.color = color
    
    def speak(self) -> str:
        """고양이 소리"""
        return f"{self.name}: 야옹~"
    
    def climb(self) -> str:
        """나무 오르기"""
        return f"{self.name}이(가) 나무를 올라갑니다"

# 다형성 활용
animals = [
    Dog("멍멍이", "골든 리트리버"),
    Cat("야옹이", "주황색"),
    Dog("바둑이", "진돗개")
]

# 모든 동물이 speak() 메서드를 가지고 있지만 각각 다르게 동작
for animal in animals:
    print(f"{animal.get_info()}")
    print(f"  소리: {animal.speak()}")
    print(f"  움직임: {animal.move()}")
    
    # 타입별 특별한 동작
    if isinstance(animal, Dog):
        print(f"  특기: {animal.fetch()}")
    elif isinstance(animal, Cat):
        print(f"  특기: {animal.climb()}")
    print()
```

### 다중 상속과 MRO (Method Resolution Order)
- 다중 상속: 하나의 클래스가 여러 개의 부모 클래스로부터 속성과 메서드를 상속받는 것 
- 파이썬에서 다중 상속시 어떤 순서로 메서드를 탐색할지 정하는 규칙 
```python
class A:
    def say(self):
        print("A")

class B:
    def say(self):
        print("B")

class C(A, B):  # 다중 상속
    pass

c = C()
c.say()  # A 출력됨. 왜? MRO 

# MRO 확인 방법 
print(C.mro())
# 또는
help(C)
# 결과 예시
# [<class '__main__.C'>, <class '__main__.A'>, <class '__main__.B'>, <class 'object'>]

# 예시 2. 
class A:
    def say(self):
        print("A")

class B(A):
    def say(self):
        print("B")

class C(A):
    def say(self):
        print("C")

class D(B, C):
    pass

d = D()
d.say()  # ??
print(D.mro())
# B
# [<class '__main__.D'>, <class '__main__.B'>, <class '__main__.C'>, <class '__main__.A'>, <class 'object'>]

""" 
D는 B, C를 상속받았지만 B가 A를 먼저 상속받고, C도 A를 상속한 상황 
따라서 B -> C -> A 순서로 메서드가 탐색됨 
즉, MRO 순서대로 메서드를 찾다가 처음 발견되면 그걸 실행함.
=> 다중 상속시 이름 충돌이 있으면 MRO에 따라 우선순위가 결점됨에 유의!
"""
```

---

## 3. 추상 클래스와 인터페이스
- 파이썬에서는 추상클래스가 인터페이스 역할까지 포함한다 (unlike e.g. C#)
### 추상 클래스
- 추상클래스를 사용하는 이유는 2가지:
    - 공통된 인터페이스를 강제하기 위해 
    - 다형성 + 코드 일관성 유지 
    - 예:
    ```python 
    from abc import ABC, abstractmethod

    class Animal(ABC):
        @abstractmethod
        def speak(self):
            # 공통된 인터페이스를 강제하기 위해 -> 구현을 깜박하는 실수 방지. 협업할 때도 팀원간 암묵적 규약 없이 코드로 명시 가능.
            pass

    class Dog(Animal):
        def speak(self):
            print("멍멍")

    class Cat(Animal):
        def speak(self):
            print("야옹")

    # 다형성 + 코드 일관성 유지 
    def call_speak(animal: Animal):
        animal.speak()

    call_speak(Dog())
    call_speak(Cat())
    ```

---

## 4. 매직 메서드와 연산자 오버로딩
- 예: 
```python
class Product:
    """상품 클래스 - 다양한 매직 메서드 포함"""
    
    def __init__(self, name: str, price: int):
        self.name = name
        self.price = price

    def __str__(self):
        """사용자 친화적 문자열"""
        return f"{self.name} 상품 - {self.price}원"

    def __repr__(self):
        """디버깅/로깅용 표현"""
        # 원래 객체가 상속받은 __repr__을 사용하면 객체 주소를 반환해서 너무 추상적 -> 커스텀 해서 개발자가 디버깅 하기 용이하게 사용 
        return f"Product(name='{self.name}', price={self.price})"

    def __eq__(self, other):
        """같은 상품인지 비교"""
        return isinstance(other, Product) and self.name == other.name and self.price == other.price

    def __hash__(self):
        """set이나 dict key로 사용 가능하게 함"""
        return hash((self.name, self.price))

    def __add__(self, other):
        """상품 가격 더하기 (묶음 상품 계산 등)"""
        if isinstance(other, Product):
            return self.price + other.price
        return NotImplemented

    def __len__(self):
        """상품명 길이 반환 (len(product))"""
        return len(self.name)

    def __call__(self):
        """상품을 호출하면 소개 메시지 출력"""
        return f"{self.name}는 {self.price}원입니다."

# 사용 예시
p1 = Product("라면", 800)
p2 = Product("삼각김밥", 1200)
p3 = Product("라면", 800)

print(p1)               # ✅ __str__ → 라면 상품 - 800원
print(repr(p1))         # ✅ __repr__ → Product(name='라면', price=800)
print(p1 == p3)         # ✅ __eq__ → True
print(p1 + p2)          # ✅ __add__ → 2000
print(len(p1))          # ✅ __len__ → 2 (라면)
print(p1())             # ✅ __call__ → 라면는 800원입니다.

# ✅ __hash__ 덕분에 set에 넣을 수 있음
products = {p1, p2, p3}
print(products)         # {Product(name='삼각김밥', price=1200), Product(name='라면', price=800)} ← 중복 제거됨

# cf. 유의!
repr(p1)           # 실제로는 p1.__repr__() 호출
str(p1)            # 실제로는 p1.__str__() 호출
len(p1)            # 실제로는 p1.__len__() 호출
```

---



여기부터!






## 5. 프로퍼티와 디스크립터
- @property는 메서드를 마치 속성처럼 사용할 수 있게 해주는 파이썬 내장 데코레이터
- getter, setter, deleter를 조합해 속성 접근을 제어하는 데 사용

### 프로퍼티 활용
- 
```python
class Circle:
    """원 클래스 - 프로퍼티 활용"""
    
    def __init__(self, radius: float):
        self._radius = radius
    
    @property
    def radius(self) -> float:
        """반지름 (읽기 전용)"""
        return self._radius
    
    @radius.setter
    def radius(self, value: float) -> None:
        """반지름 설정"""
        if value < 0:
            raise ValueError("반지름은 음수일 수 없습니다")
        self._radius = value
    
    @property
    def diameter(self) -> float:
        """지름 (읽기 전용)"""
        return self._radius * 2
    
    @diameter.setter
    def diameter(self, value: float) -> None:
        """지름으로 반지름 설정"""
        self.radius = value / 2
    
    @property
    def area(self) -> float:
        """면적 (읽기 전용)"""
        import math
        return math.pi * self._radius ** 2
    
    @property
    def circumference(self) -> float:
        """둘레 (읽기 전용)"""
        import math
        return 2 * math.pi * self._radius
    
    def __str__(self) -> str:
        return f"Circle(radius={self._radius})"

# 사용 예시
circle = Circle(5)
print(f"원: {circle}")
print(f"반지름: {circle.radius}")
print(f"지름: {circle.diameter}")
print(f"면적: {circle.area:.2f}")
print(f"둘레: {circle.circumference:.2f}")

# 반지름 변경
circle.radius = 10
print(f"반지름 변경 후: {circle.radius}")

# 지름으로 변경
circle.diameter = 6
print(f"지름 6으로 변경 후 반지름: {circle.radius}")

# 에러 케이스
try:
    circle.radius = -5
except ValueError as e:
    print(f"에러: {e}")
```

### 디스크립터
```python
class ValidatedField:
    """검증 가능한 필드 디스크립터"""
    
    def __init__(self, min_length: int = 0, max_length: int = None):
        self.min_length = min_length
        self.max_length = max_length
        self.name = None
    
    def __set_name__(self, owner, name):
        """디스크립터 이름 설정"""
        self.name = name
    
    def __get__(self, instance, owner):
        """값 가져오기"""
        if instance is None:
            return self
        return instance.__dict__.get(self.name)
    
    def __set__(self, instance, value):
        """값 설정 (검증 포함)"""
        if not isinstance(value, str):
            raise TypeError(f"{self.name}은 문자열이어야 합니다")
        
        if len(value) < self.min_length:
            raise ValueError(f"{self.name}은 최소 {self.min_length}자 이상이어야 합니다")
        
        if self.max_length and len(value) > self.max_length:
            raise ValueError(f"{self.name}은 최대 {self.max_length}자 이하여야 합니다")
        
        instance.__dict__[self.name] = value

class PositiveNumber:
    """양수 필드 디스크립터"""
    
    def __init__(self, min_value: float = 0):
        self.min_value = min_value
        self.name = None
    
    def __set_name__(self, owner, name):
        self.name = name
    
    def __get__(self, instance, owner):
        if instance is None:
            return self
        return instance.__dict__.get(self.name)
    
    def __set__(self, instance, value):
        if not isinstance(value, (int, float)):
            raise TypeError(f"{self.name}은 숫자여야 합니다")
        
        if value < self.min_value:
            raise ValueError(f"{self.name}은 {self.min_value} 이상이어야 합니다")
        
        instance.__dict__[self.name] = value

class Product:
    """상품 클래스 - 디스크립터 활용"""
    
    # 디스크립터로 필드 정의
    name = ValidatedField(min_length=1, max_length=100)
    description = ValidatedField(min_length=0, max_length=1000)
    price = PositiveNumber(min_value=0)
    stock = PositiveNumber(min_value=0)
    
    def __init__(self, name: str, description: str, price: float, stock: int):
        self.name = name
        self.description = description
        self.price = price
        self.stock = stock
    
    def __str__(self) -> str:
        return f"Product(name='{self.name}', price={self.price}, stock={self.stock})"

# 사용 예시
try:
    product = Product("노트북", "고성능 노트북", 1500000, 10)
    print(f"상품 생성 성공: {product}")
    
    # 유효하지 않은 값 설정 시도
    product.price = -1000
except ValueError as e:
    print(f"가격 설정 에러: {e}")

try:
    product.name = ""  # 빈 문자열
except ValueError as e:
    print(f"이름 설정 에러: {e}")
```

---

## 6. 믹스인과 컴포지션

### 믹스인 패턴
```python
class LoggingMixin:
    """로깅 기능 믹스인"""
    
    def log_info(self, message: str) -> None:
        print(f"[INFO] {self.__class__.__name__}: {message}")
    
    def log_error(self, message: str, error: Exception = None) -> None:
        error_msg = f" - {error}" if error else ""
        print(f"[ERROR] {self.__class__.__name__}: {message}{error_msg}")
    
    def log_warning(self, message: str) -> None:
        print(f"[WARNING] {self.__class__.__name__}: {message}")

class ValidationMixin:
    """검증 기능 믹스인"""
    
    def validate_not_empty(self, value: str, field_name: str) -> bool:
        if not value or not value.strip():
            raise ValueError(f"{field_name}은 비어있을 수 없습니다")
        return True
    
    def validate_email(self, email: str) -> bool:
        if '@' not in email or '.' not in email.split('@')[1]:
            raise ValueError("유효하지 않은 이메일 형식입니다")
        return True
    
    def validate_age(self, age: int) -> bool:
        if not isinstance(age, int) or age < 0 or age > 150:
            raise ValueError("나이는 0-150 사이의 정수여야 합니다")
        return True

class SerializationMixin:
    """직렬화 기능 믹스인"""
    
    def to_dict(self) -> dict:
        """객체를 딕셔너리로 변환"""
        result = {}
        for key, value in self.__dict__.items():
            if not key.startswith('_'):
                result[key] = value
        return result
    
    def to_json(self) -> str:
        """객체를 JSON 문자열로 변환"""
        import json
        return json.dumps(self.to_dict(), ensure_ascii=False, indent=2)
    
    @classmethod
    def from_dict(cls, data: dict):
        """딕셔너리에서 객체 생성"""
        return cls(**data)

class User(LoggingMixin, ValidationMixin, SerializationMixin):
    """사용자 클래스 - 믹스인 활용"""
    
    def __init__(self, name: str, email: str, age: int):
        # 검증
        self.validate_not_empty(name, "이름")
        self.validate_email(email)
        self.validate_age(age)
        
        # 속성 설정
        self.name = name
        self.email = email
        self.age = age
        
        # 로깅
        self.log_info(f"사용자 생성됨: {name}")
    
    def update_profile(self, **kwargs) -> None:
        """프로필 업데이트"""
        self.log_info("프로필 업데이트 시작")
        
        try:
            for key, value in kwargs.items():
                if hasattr(self, key):
                    # 검증 후 설정
                    if key == 'name':
                        self.validate_not_empty(value, "이름")
                    elif key == 'email':
                        self.validate_email(value)
                    elif key == 'age':
                        self.validate_age(value)
                    
                    setattr(self, key, value)
                    self.log_info(f"{key} 업데이트됨: {value}")
            
            self.log_info("프로필 업데이트 완료")
            
        except Exception as e:
            self.log_error("프로필 업데이트 실패", e)
            raise

# 사용 예시
try:
    user = User("김철수", "kim@example.com", 25)
    print(f"사용자 생성: {user.name}")
    
    # 프로필 업데이트
    user.update_profile(age=26, email="kim.new@example.com")
    
    # 직렬화
    user_dict = user.to_dict()
    print(f"사용자 딕셔너리: {user_dict}")
    
    user_json = user.to_json()
    print(f"사용자 JSON: {user_json}")
    
    # 딕셔너리에서 복원
    restored_user = User.from_dict(user_dict)
    print(f"복원된 사용자: {restored_user.name}")
    
except Exception as e:
    print(f"에러 발생: {e}")
```

### 컴포지션 패턴
```python
class EmailService:
    """이메일 서비스"""
    
    def send_email(self, to: str, subject: str, body: str) -> bool:
        print(f"이메일 전송: {to} - {subject}")
        return True

class SMSService:
    """SMS 서비스"""
    
    def send_sms(self, to: str, message: str) -> bool:
        print(f"SMS 전송: {to} - {message}")
        return True

class NotificationService:
    """알림 서비스 - 컴포지션 활용"""
    
    def __init__(self):
        # 서비스들을 컴포지션으로 포함
        self.email_service = EmailService()
        self.sms_service = SMSService()
    
    def send_notification(self, user_id: str, message: str, 
                         channels: list = None) -> dict:
        """알림 전송"""
        if channels is None:
            channels = ['email']
        
        results = {}
        
        if 'email' in channels:
            results['email'] = self.email_service.send_email(
                f"{user_id}@example.com", 
                "알림", 
                message
            )
        
        if 'sms' in channels:
            results['sms'] = self.sms_service.send_sms(
                f"+82-10-{user_id}", 
                message
            )
        
        return results
    
    def send_bulk_notification(self, users: list, message: str, 
                              channels: list = None) -> dict:
        """대량 알림 전송"""
        results = {'success': 0, 'failed': 0}
        
        for user in users:
            try:
                result = self.send_notification(user['id'], message, channels)
                if all(result.values()):
                    results['success'] += 1
                else:
                    results['failed'] += 1
            except Exception as e:
                results['failed'] += 1
                print(f"사용자 {user['id']} 알림 전송 실패: {e}")
        
        return results

# 사용 예시
notification_service = NotificationService()

# 단일 알림
result = notification_service.send_notification(
    "user123", 
    "안녕하세요! 새로운 기능이 추가되었습니다.",
    ['email', 'sms']
)
print(f"알림 전송 결과: {result}")

# 대량 알림
users = [
    {'id': 'user1', 'name': '김철수'},
    {'id': 'user2', 'name': '이영희'},
    {'id': 'user3', 'name': '박민수'}
]

bulk_result = notification_service.send_bulk_notification(
    users, 
    "시스템 점검이 예정되어 있습니다.",
    ['email']
)
print(f"대량 알림 결과: {bulk_result}")
```

---

## 7. 디자인 패턴

### 싱글톤 패턴
```python
class SingletonMeta(type):
    """메타클래스를 사용한 싱글톤 패턴"""
    
    def __init__(cls, name, bases, namespace):
        super().__init__(name, bases, namespace)
        cls._instance = None
        cls._lock = None
    
    def __call__(cls, *args, **kwargs):
        if cls._instance is None:
            # 스레드 안전을 위한 락 생성
            if cls._lock is None:
                import threading
                cls._lock = threading.Lock()
            
            with cls._lock:
                if cls._instance is None:
                    cls._instance = super().__call__(*args, **kwargs)
        
        return cls._instance

class DatabaseConnection(metaclass=SingletonMeta):
    """데이터베이스 연결 싱글톤"""
    
    def __init__(self):
        self.connection_string = "postgresql://localhost:5432/mydb"
        self.is_connected = False
        print("데이터베이스 연결 객체 생성됨")
    
    def connect(self):
        """데이터베이스 연결"""
        if not self.is_connected:
            self.is_connected = True
            print(f"데이터베이스에 연결됨: {self.connection_string}")
        return self.is_connected
    
    def disconnect(self):
        """데이터베이스 연결 해제"""
        if self.is_connected:
            self.is_connected = False
            print("데이터베이스 연결 해제됨")
    
    def execute_query(self, query: str) -> str:
        """쿼리 실행"""
        if not self.is_connected:
            raise ConnectionError("데이터베이스에 연결되지 않았습니다")
        return f"쿼리 실행: {query}"

# 사용 예시
db1 = DatabaseConnection()
db2 = DatabaseConnection()

print(f"db1 is db2: {db1 is db2}")  # True
print(f"db1 id: {id(db1)}")
print(f"db2 id: {id(db2)}")

db1.connect()
db2.connect()  # 이미 연결된 상태

result = db1.execute_query("SELECT * FROM users")
print(result)
```

### 팩토리 패턴
```python
from abc import ABC, abstractmethod
from typing import Dict, Type

class PaymentMethod(ABC):
    """결제 방법 추상 클래스"""
    
    @abstractmethod
    def process_payment(self, amount: float) -> bool:
        pass
    
    @abstractmethod
    def get_fee(self, amount: float) -> float:
        pass

class CreditCardPayment(PaymentMethod):
    """신용카드 결제"""
    
    def process_payment(self, amount: float) -> bool:
        print(f"신용카드로 {amount}원 결제 처리")
        return True
    
    def get_fee(self, amount: float) -> float:
        return amount * 0.03  # 3% 수수료

class BankTransferPayment(PaymentMethod):
    """계좌이체 결제"""
    
    def process_payment(self, amount: float) -> bool:
        print(f"계좌이체로 {amount}원 결제 처리")
        return True
    
    def get_fee(self, amount: float) -> float:
        return amount * 0.01  # 1% 수수료

class CryptoPayment(PaymentMethod):
    """암호화폐 결제"""
    
    def process_payment(self, amount: float) -> bool:
        print(f"암호화폐로 {amount}원 결제 처리")
        return True
    
    def get_fee(self, amount: float) -> float:
        return amount * 0.005  # 0.5% 수수료

class PaymentFactory:
    """결제 방법 팩토리"""
    
    _payment_methods: Dict[str, Type[PaymentMethod]] = {
        'credit_card': CreditCardPayment,
        'bank_transfer': BankTransferPayment,
        'crypto': CryptoPayment
    }
    
    @classmethod
    def create_payment_method(cls, method_type: str) -> PaymentMethod:
        """결제 방법 생성"""
        if method_type not in cls._payment_methods:
            raise ValueError(f"지원하지 않는 결제 방법: {method_type}")
        
        return cls._payment_methods[method_type]()
    
    @classmethod
    def register_payment_method(cls, name: str, payment_class: Type[PaymentMethod]):
        """새로운 결제 방법 등록"""
        cls._payment_methods[name] = payment_class
    
    @classmethod
    def get_supported_methods(cls) -> list:
        """지원하는 결제 방법 목록 반환"""
        return list(cls._payment_methods.keys())

class PaymentProcessor:
    """결제 처리기"""
    
    def __init__(self):
        self.factory = PaymentFactory()
    
    def process_payment(self, method_type: str, amount: float) -> dict:
        """결제 처리"""
        try:
            payment_method = self.factory.create_payment_method(method_type)
            
            # 수수료 계산
            fee = payment_method.get_fee(amount)
            total_amount = amount + fee
            
            # 결제 처리
            success = payment_method.process_payment(amount)
            
            return {
                'success': success,
                'amount': amount,
                'fee': fee,
                'total_amount': total_amount,
                'method': method_type
            }
            
        except Exception as e:
            return {
                'success': False,
                'error': str(e),
                'method': method_type
            }

# 사용 예시
processor = PaymentProcessor()

# 지원하는 결제 방법 확인
print(f"지원하는 결제 방법: {PaymentFactory.get_supported_methods()}")

# 다양한 결제 방법으로 결제
payment_methods = ['credit_card', 'bank_transfer', 'crypto']
amount = 100000

for method in payment_methods:
    result = processor.process_payment(method, amount)
    if result['success']:
        print(f"{method}: {result['amount']}원 + 수수료 {result['fee']}원 = 총 {result['total_amount']}원")
    else:
        print(f"{method} 결제 실패: {result['error']}")
```


---

<details>
<summary>cf. reference</summary>

- 
</details> 